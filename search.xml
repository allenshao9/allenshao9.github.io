<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CPU使用率过高问题排查</title>
    <url>/Linux/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CPU_troubleshoot/</url>
    <content><![CDATA[<h1 id="CPU使用率过高问题排查"><a href="#CPU使用率过高问题排查" class="headerlink" title="CPU使用率过高问题排查"></a>CPU使用率过高问题排查</h1><blockquote>
<p>一个应用占用CPU很高，除了确实是计算密集型应用之外，通常原因都是出现了死循环。<br>下面我们将一步步定位问题以及排查思路。</p>
</blockquote>
<h2 id="一、定位占用cpu高的进程"><a href="#一、定位占用cpu高的进程" class="headerlink" title="一、定位占用cpu高的进程"></a>一、定位占用cpu高的进程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#linux下使用top</span><br><span class="line">top</span><br><span class="line">#AIX下使用topas</span><br><span class="line">topas</span><br></pre></td></tr></table></figure>

<img src="/Linux/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CPU_troubleshoot/image-20200714103622358.png" alt="image-20200714103622358" style="zoom:70%;"> 

<p>通过上图可以明显看出进程PID6359占用cpu过高，明显存在问题，定位到了进程id。</p>
<p>可以使用以下命令top -p pid只观察此进程的CPU和内存以及负载情况。</p>
<h2 id="二、定位进程中每个线程占用cpu情况"><a href="#二、定位进程中每个线程占用cpu情况" class="headerlink" title="二、定位进程中每个线程占用cpu情况"></a>二、定位进程中每个线程占用cpu情况</h2><p><strong>1. 使用top查看进程的每一个线程占用CPU情况</strong></p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top -Hp pid</span><br></pre></td></tr></table></figure>

<img src="/Linux/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CPU_troubleshoot/image-20200714103744375.png" alt="image-20200714103744375" style="zoom:70%;"> 

<p>通过上图可以看出线程PID6360CPU占用率最高，接下来定位该线程的代码是否出现异常导致cpu占用过高。</p>
<p><strong>2. 使用ps查看进程的每一个线程占用CPU情况</strong></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ps -mp pid -o THREAD,tid,time | sort -rn</span><br></pre></td></tr></table></figure>

<img src="/Linux/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CPU_troubleshoot/image-20200714104157960.png" alt="image-20200714104157960" style="zoom:80%;"> 

<h2 id="三、定位线程Dump定位程序问题"><a href="#三、定位线程Dump定位程序问题" class="headerlink" title="三、定位线程Dump定位程序问题"></a>三、定位线程Dump定位程序问题</h2><p><strong>1. 生产线程Dump文件</strong></p>
<ul>
<li><p>使用jstack命令定位问题代码</p>
<blockquote>
<p>#输出线程dump文件用于分析<br>jstack pid &gt;jstack.txt</p>
</blockquote>
</li>
<li><p>用Kill -3 pid 生成</p>
<blockquote>
<p>  一般是生产在nohup文件 、AIX会生成javacore关键字文件（一般是生产在程序启动目录下）</p>
</blockquote>
</li>
</ul>
<p><strong>2.通过上一步定位线程较高的pid转换为16进制。</strong></p>
<p>printf “%x\n” 6360   为181d</p>
<p><strong>3.查找线程dump文件中线程执行的代码</strong></p>
<img src="/Linux/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CPU_troubleshoot/image-20200714110322979.png" alt="image-20200714110322979" style="zoom:60%;"> 

<p><strong>4.通过程序进行定位对应的执行代码</strong></p>
<p>发现代码中while循环无法结束，一直抢占cpu，导致程序cpu使用过高，修改代码即可。</p>
<img src="/Linux/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CPU_troubleshoot/image-20200714105228482.png" alt="image-20200714105228482" style="zoom:50%;"> ]]></content>
      <categories>
        <category>Linux</category>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle事务&amp;锁</title>
    <url>/Oracle/Oracle_Tran/</url>
    <content><![CDATA[<h1 id="Oracle事务-amp-锁"><a href="#Oracle事务-amp-锁" class="headerlink" title="Oracle事务&amp;锁"></a>Oracle事务&amp;锁</h1><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p>在关系型数据库（BD2,Oracle,Sybase,Informix和Sql Server）最小的恢复和交易单位为一个事务，事务具有ACID（原子性，一致性，隔离性，永久性）特征。关系数据库为了确保并发用户在存取同一数据库对象的正确性（即无脏读，无丢失更新，可重复读，无幻读），数据库中引入了锁机制。基本的锁类型：共享锁S和排它锁X。</p>
<h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><h2 id="Oracle锁机制"><a href="#Oracle锁机制" class="headerlink" title="Oracle锁机制"></a>Oracle锁机制</h2><p>准备更新中…… </p>
<p>​    </p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>事务&amp;锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux性能分析工具合集</title>
    <url>/Linux/Linux_performance/</url>
    <content><![CDATA[<h1 id="Linux性能分析工具合集"><a href="#Linux性能分析工具合集" class="headerlink" title="Linux性能分析工具合集"></a>Linux性能分析工具合集</h1><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>有时候会遇到一些疑难杂症，并且监控插件并不能一眼立马发现问题的根源。这时候就需要登录服务器进一步深入分析问题的根源。那么分析问题需要有一定的技术经验积累，并且有些问题涉及到的领域非常广，才能定位到问题。所以，分析问题和踩坑是非常锻炼一个人的成长和提升自我能力。如果我们有一套好的分析工具，那将是事半功倍，能够帮助大家快速定位问题，节省大家很多时间做更深入的事情。</p>
<h2 id="2-说明"><a href="#2-说明" class="headerlink" title="2. 说明"></a>2. 说明</h2><p>本篇文章主要介绍各种问题定位的工具以及会结合案例分析问题。</p>
<h2 id="3-分析问题的方法论"><a href="#3-分析问题的方法论" class="headerlink" title="3. 分析问题的方法论"></a>3. 分析问题的方法论</h2><p>套用5W2H方法，可以提出性能分析的几个问题</p>
<ul>
<li>What-现象是什么样的</li>
<li>When-什么时候发生</li>
<li>Why-为什么会发生</li>
<li>Where-哪个地方发生的问题</li>
<li>How much-耗费了多少资源</li>
<li>How to do-怎么解决问题</li>
</ul>
<h2 id="4-性能分析工具合集"><a href="#4-性能分析工具合集" class="headerlink" title="4.性能分析工具合集"></a>4.性能分析工具合集</h2><img src="/Linux/Linux_performance/linux_xn.png" alt="img" style="zoom:60%;">

<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><p>针对应用程序，我们通常关注的是内核CPU调度器功能和性能。</p>
<p>线程的状态分析主要是分析线程的时间用在什么地方，而线程状态的分类一般分为：</p>
<p>a. on-CPU：执行中，执行中的时间通常又分为用户态时间user和系统态时间sys。<br>        b. off-CPU：等待下一轮上CPU，或者等待I/O、锁、换页等等，其状态可以细分为可执行、匿名换页、睡        眠、锁、空闲等状态。</p>
<h4 id="分析工具"><a href="#分析工具" class="headerlink" title="分析工具"></a><strong>分析工具</strong></h4><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>uptime/w</td>
<td>查看服务器运行时间、平均负载</td>
</tr>
<tr>
<td>top</td>
<td>监控每个进程的CPU用量分解</td>
</tr>
<tr>
<td>vmstat</td>
<td>系统的CPU平均负载情况</td>
</tr>
<tr>
<td>mpstat</td>
<td>查看多核CPU信息</td>
</tr>
<tr>
<td>sar -u</td>
<td>查看CPU过去或未来时点CPU利用率</td>
</tr>
<tr>
<td>pidstat</td>
<td>查看每个进程的用量分解</td>
</tr>
</tbody></table>
<h4 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h4><p>uptime 命令可以用来查看服务器已经运行了多久，当前登录的用户有多少，以及服务器在过去的1分钟、5分钟、15分钟的系统平均负载值</p>
<img src="/Linux/Linux_performance/image-20200604180851790.png" alt="image-20200604180851790" style="zoom:95%;">

<p>第一项是当前时间，up 表示系统正在运行，6:47是系统启动的总时间，最后是系统的负载load信息</p>
<p>w 同上，增加了具体登陆了那些用户及登陆时间。</p>
<h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><p>常用来监控<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">Linux</a>的系统状况，比如cpu、内存的使用，显示系统上正在运行的进程。</p>
<img src="/Linux/Linux_performance/image-20200604181133355.png" alt="image-20200604181133355" style="zoom:76%;">

<ol>
<li><p><strong>系统运行时间和平均负载：</strong></p>
<p>top命令的顶部显示与uptime命令相似的输出。</p>
<p>这些字段显示：</p>
<ul>
<li>当前时间</li>
<li>系统已运行的时间</li>
<li>当前登录用户的数量</li>
<li>相应最近5、10和15分钟内的平均负载。</li>
</ul>
</li>
<li><p><strong>任务</strong></p>
<p>第二行显示的是任务或者进程的总结。进程可以处于不同的状态。这里显示了全部进程的数量。除此之外，还有正在运行、睡眠、停止、僵尸进程的数量（僵尸是一种进程的状态）。这些进程概括信息可以用’t’切换显示。</p>
</li>
<li><p><strong>CPU状态</strong></p>
<p>下一行显示的是CPU状态。 这里显示了不同模式下的所占CPU时间的百分比。这些不同的CPU时间表示:</p>
<ul>
<li>us, user： 运行(未调整优先级的) 用户进程的CPU时间</li>
<li>sy，system: 运行内核进程的CPU时间</li>
<li>ni，niced：运行已调整优先级的用户进程的CPU时间</li>
<li>wa，IO wait: 用于等待IO完成的CPU时间</li>
<li>hi：处理硬件中断的CPU时间</li>
<li>si: 处理软件中断的CPU时间</li>
<li>st：这个虚拟机被hypervisor偷去的CPU时间（译注：如果当前处于一个hypervisor下的vm，实际上hypervisor也是要消耗一部分CPU处理时间的）。</li>
</ul>
</li>
<li><p><strong>内存使用</strong></p>
<p>接下来两行显示内存使用率，有点像’free’命令。第一行是物理内存使用，第二行是虚拟内存使用(交换空间)。</p>
<p>物理内存显示如下:全部可用内存、已使用内存、空闲内存、缓冲内存。相似地：交换部分显示的是：全部、已使用、空闲和缓冲交换空间。</p>
<blockquote>
<p>这里要说明的是不能用windows的内存概念理解这些数据，如果按windows的方式此台服务器“危矣”：8G的内存总量只剩下530M的可用内存。Linux的内存管理有其特殊性，复杂点需要一本书来说明，这里只是简单说点和我们传统概念（windows）的不同。</p>
<p>第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在<a href="http://lib.csdn.net/base/linux" target="_blank" rel="noopener">linux</a>上free内存会越来越少，但不用为此担心。</p>
<p>如果出于习惯去计算可用内存数，这里有个近似的计算公式：</p>
<p>​        <strong>第四行的free + 第四行的buffers + 第五行的cached。</strong></p>
<p>对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p>
</blockquote>
</li>
<li><p><strong>字段/列</strong></p>
<table>
<thead>
<tr>
<th>进程的属性</th>
<th>属性含义</th>
</tr>
</thead>
<tbody><tr>
<td>PID</td>
<td>进程ID，进程的唯一标识符</td>
</tr>
<tr>
<td>USER</td>
<td>进程所有者的实际用户名。</td>
</tr>
<tr>
<td>PR</td>
<td>进程的调度优先级。这个字段的一些值是’rt’。这意味这这些进程运行在实时态。</td>
</tr>
<tr>
<td>NI</td>
<td>进程的nice值（优先级）。越小的值意味着越高的优先级。</td>
</tr>
<tr>
<td>VIRT</td>
<td>进程使用的虚拟内存。</td>
</tr>
<tr>
<td>RES</td>
<td>驻留内存大小。驻留内存是任务使用的非交换物理内存大小。</td>
</tr>
<tr>
<td>SHR</td>
<td>SHR是进程使用的共享内存。</td>
</tr>
<tr>
<td>S</td>
<td>这个是进程的状态。它有以下不同的值:<br>D–不可中断的睡眠态、R–运行态、S–睡眠态、T–被跟踪或已停止、Z – 僵尸态</td>
</tr>
<tr>
<td>%CPU</td>
<td>自从上一次更新时到现在任务所使用的CPU时间百分比。</td>
</tr>
<tr>
<td>%MEM</td>
<td>进程使用的可用物理内存百分比。</td>
</tr>
<tr>
<td>TIME+</td>
<td>任务启动后到现在所使用的全部CPU时间，精确到百分之一秒。</td>
</tr>
<tr>
<td>COMMAND</td>
<td>运行进程所使用的命令。</td>
</tr>
</tbody></table>
<p>还有许多在默认情况下不会显示的输出，它们可以显示进程的页错误、有效组和组ID和其他更多的信息。</p>
<p>常用交互命令：</p>
<p>‘B’：一些重要信息会以加粗字体显示(高亮)。这个命令可以切换粗体显示。</p>
<p>‘b’:</p>
<p>‘D’或’S‘: 你将被提示输入一个值（以秒为单位），它会以设置的值作为刷新间隔。如果你这里输入了1，top将会每秒刷新。 top默认为3秒刷新</p>
<p>‘l’、‘t’、‘m’: 切换负载、任务、内存信息的显示，这会相应地切换顶部的平均负载、任务/CPU状态和内存信息的概况显示。</p>
<p>‘z’ : 切换彩色显示</p>
<p>‘x’ 或者 ‘y’</p>
<p>切换高亮信息：’x’将排序字段高亮显示（纵列）；’y’将运行进程高亮显示（横行）。依赖于你的显示设置，你可能需要让输出彩色来看到这些高亮。</p>
<p>‘u’: 特定用户的进程</p>
<p>‘n’ 或 ‘#’: 任务的数量</p>
<p>‘k’: 结束任务</p>
<p><strong>命令行选项</strong></p>
<blockquote>
<p>top  //每隔3秒显式所有进程的资源占用情况</p>
<p>top -u oracle -c //按照用户显示进程、并显示完整命令 </p>
<p>top -d 2 //每隔2秒显式所有进程的资源占用情况</p>
<p>top -c //每隔3秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)</p>
<p>top -p 12345 -p 6789//每隔3秒显示pid是12345和pid是6789的两个进程的资源占用情况</p>
<p>top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数</p>
<p>top -n  设置显示多少次后就退出</p>
</blockquote>
<p><strong>补充</strong></p>
<p>top命令是Linux上进行系统监控的首选命令，但有时候却达不到我们的要求，比如当前这台服务器，top监控有很大的局限性。这台服务器运行着websphere集群，有两个节点服务，就是【top视图 01】中的老大、老二两个java进程，top命令的监控最小单位是进程，所以看不到我关心的java线程数和客户连接数，而这两个指标是java的web服务非常重要的指标，通常我用ps和netstate两个命令来补充top的不足。</p>
</li>
</ol>
<h4 id="vmstat"><a href="#vmstat" class="headerlink" title="vmstat"></a>vmstat</h4><p>​    vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。</p>
<p>​    一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如:</p>
<img src="/Linux/Linux_performance/image-20200604203027136.png" alt="image-20200604203027136" style="zoom:75%;">

<p>每个参数的含义：</p>
<p><strong>Procs（进程）</strong></p>
<table>
<thead>
<tr>
<th>r:</th>
<th>运行队列中进程数量，这个值也可以判断是否需要增加CPU。（长期大于1）</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>等待IO的进程数量。</td>
</tr>
</tbody></table>
<p><strong>Memory（内存）</strong></p>
<table>
<thead>
<tr>
<th>swpd</th>
<th>使用虚拟内存大小，如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。</th>
</tr>
</thead>
<tbody><tr>
<td>free</td>
<td>空闲物理内存大小。</td>
</tr>
<tr>
<td>buff</td>
<td>用作缓冲的内存大小。</td>
</tr>
<tr>
<td>cache</td>
<td>用作缓存的内存大小，如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。</td>
</tr>
</tbody></table>
<p><strong>Swap</strong></p>
<table>
<thead>
<tr>
<th>si</th>
<th>每秒从交换区写到内存的大小，由磁盘调入内存。</th>
</tr>
</thead>
<tbody><tr>
<td>so</td>
<td>每秒写入交换区的内存大小，由内存调入磁盘。</td>
</tr>
</tbody></table>
<p>注意：内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。因为linux总是先把内存用光.</p>
<p><strong>IO</strong></p>
<table>
<thead>
<tr>
<th>bi</th>
<th>每秒读取的块数</th>
</tr>
</thead>
<tbody><tr>
<td>bo</td>
<td>每秒写入的块数</td>
</tr>
</tbody></table>
<p>注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。</p>
<p><strong>system（系统）</strong></p>
<table>
<thead>
<tr>
<th>in</th>
<th>每秒中断数，包括时钟中断。</th>
</tr>
</thead>
<tbody><tr>
<td>cs</td>
<td>每秒上下文切换数。</td>
</tr>
</tbody></table>
<p>注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。</p>
<p><strong>CPU（以百分比表示）</strong></p>
<table>
<thead>
<tr>
<th>us</th>
<th>用户进程执行时间百分比(user  time) us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。</th>
</tr>
</thead>
<tbody><tr>
<td>sy:</td>
<td>内核系统进程执行时间百分比(system  time) sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。</td>
</tr>
<tr>
<td>wa</td>
<td>IO等待时间百分比  wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。</td>
</tr>
<tr>
<td>id</td>
<td>空闲时间百分比</td>
</tr>
</tbody></table>
<h4 id="mpstat"><a href="#mpstat" class="headerlink" title="mpstat"></a>mpstat</h4><p>​    mpstat是一个实时监控工具，主要报告与CPU相关统计信息,在多核心cpu系统中，不仅可以查看cpu平均信息，还可以查看指定cpu信息。</p>
<blockquote>
<p>mpstat -P ALL  //查看全部CPU的负载情况。 </p>
<p>mpstat 2 5  //可指定间隔时间和次数。</p>
</blockquote>
<table>
<thead>
<tr>
<th>CPU: 处理器编号。关键字all表示统计信息计算为所有处理器之间的平均值。</th>
</tr>
</thead>
<tbody><tr>
<td>％usr: 显示在用户级（应用程序）执行时发生的CPU利用率百分比。</td>
</tr>
<tr>
<td>％nice: 显示以优先级较高的用户级别执行时发生的CPU利用率百分比。</td>
</tr>
<tr>
<td>％sys: 显示在系统级（内核）执行时发生的CPU利用率百分比。请注意，这不包括维护硬件和软件的时间中断。</td>
</tr>
<tr>
<td>％iowait: 显示系统具有未完成磁盘I / O请求的CPU或CPU空闲的时间百分比。</td>
</tr>
<tr>
<td>％irq: 显示CPU或CPU用于服务硬件中断的时间百分比。</td>
</tr>
<tr>
<td>%soft: 显示CPU或CPU用于服务软件中断的时间百分比。</td>
</tr>
<tr>
<td>%steal: 显示虚拟CPU或CPU在管理程序为另一个虚拟处理器提供服务时非自愿等待的时间百分比。</td>
</tr>
<tr>
<td>%guest: 显示CPU或CPU运行虚拟处理器所花费的时间百分比。</td>
</tr>
</tbody></table>
<h4 id="sar"><a href="#sar" class="headerlink" title="sar"></a>sar</h4><p>系统活动情况报告，可以从多方面对系统的活动进行报告，包括：文件的读写情况、系统调用的使用情况、磁盘I/O、CPU效率、内存使用状况、进程活动及IPC有关的活动等</p>
<p>CPU相关：</p>
<p>sar -p （查看全天）</p>
<p>sar -u 1 10 （1：每隔一秒，10：写入10次）</p>
<p>CPU输出项-详细说明</p>
<p>CPU:all 表示统计信息为所有 CPU 的平均值。</p>
<p>%user:显示在用户级别(application)运行使用 CPU 总时间的百分比。</p>
<p>%nice:显示在用户级别，用于nice操作，所占用 CPU 总时间的百分比。</p>
<p>%system:在核心级别(kernel)运行所使用 CPU 总时间的百分比。</p>
<p>%iowait:显示用于等待I/O操作占用 CPU 总时间的百分比。</p>
<p>%steal:管理程序(hypervisor)为另一个虚拟进程提供服务而等待虚拟 CPU 的百分比。</p>
<p>%idle:显示 CPU 空闲时间占用 CPU 总时间的百分比。</p>
<h4 id="pidstat"><a href="#pidstat" class="headerlink" title="pidstat"></a>pidstat</h4><p>用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。</p>
<p>pidstat 和 pidstat -u -p ALL 是等效的。<br>        pidstat 默认显示了所有进程的cpu使用率。</p>
<p>详细说明</p>
<p>PID：进程ID</p>
<p>%usr：进程在用户空间占用cpu的百分比</p>
<p>%system：进程在内核空间占用cpu的百分比</p>
<p>%guest：进程在虚拟机占用cpu的百分比</p>
<p>%CPU：进程占用cpu的百分比</p>
<p>CPU：处理进程的cpu编号</p>
<p>Command：当前进程对应的命令</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>内存是为提高效率而生，实际分析问题的时候，内存出现问题可能不只是影响性能，而是影响服务或者引起其他问题。同样对于内存有些概念需要清楚：</p>
<ul>
<li>主存</li>
<li>虚拟内存</li>
<li>常驻内存</li>
<li>地址空间</li>
<li>OOM</li>
<li>页缓存</li>
<li>缺页</li>
<li>换页</li>
<li>交换空间</li>
<li>交换</li>
<li>用户分配器libc、glibc、libmalloc和mtmalloc</li>
<li>LINUX内核级SLUB分配器</li>
</ul>
<h4 id="分析工具-1"><a href="#分析工具-1" class="headerlink" title="分析工具"></a>分析工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>free</td>
<td>查看内存的使用情况</td>
</tr>
<tr>
<td>top</td>
<td>监控每个进程的内存使用情况</td>
</tr>
<tr>
<td>vmstat</td>
<td>虚拟内存统计信息</td>
</tr>
<tr>
<td>sar -r</td>
<td>查看内存</td>
</tr>
<tr>
<td>sar</td>
<td>查看CPU过去或未来时点CPU利用率</td>
</tr>
<tr>
<td>pidstat</td>
<td>查看每个进程的内存使用情况</td>
</tr>
</tbody></table>
<h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><p>free 命令显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。</p>
<p>Mem 行(第二行)是内存的使用情况。<br>        Swap 行(第三行)是交换空间的使用情况。<br>        total 列显示系统总的可用物理内存和交换空间大小。<br>        used 列显示已经被使用的物理内存和交换空间。<br>        free 列显示还有多少物理内存和交换空间可用使用。<br>        shared 列显示被共享使用的物理内存大小。<br>        buff/cache 列显示被 buffer 和 cache 使用的物理内存大小。<br>        available 列显示还可以被应用程序使用的物理内存大小。</p>
<p>常用命令：</p>
<blockquote>
<p>free   </p>
<p>free -g  以GB显示</p>
<p>free -m  以MB显示</p>
<p>free -h  自动转换展示</p>
<p>free -h -s  3  有时我们需要持续的观察内存的状况，此时可以使用 -s 选项并指定间隔的秒数</p>
</blockquote>
<p>所以从应用程序的角度来说，<strong>available = free + buffer + cache</strong></p>
<p>可用内存=系统free memory+buffers+cached。</p>
<h4 id="top-1"><a href="#top-1" class="headerlink" title="top"></a>top</h4><p>请参考上面top的详解</p>
<h4 id="vmstat-1"><a href="#vmstat-1" class="headerlink" title="vmstat"></a>vmstat</h4><p>请参考上面vmstat的详解</p>
<h4 id="sar-1"><a href="#sar-1" class="headerlink" title="sar"></a>sar</h4><p>sar -r  #查看内存使用情况</p>
<p>详解：</p>
<p>kbmemfree  空闲的物理内存大小</p>
<p>kbmemused  使用中的物理内存大小</p>
<p>%memused 物理内存使用率</p>
<p>kbbuffers 内核中作为缓冲区使用的物理内存大小，kbbuffers和kbcached:这两个值就是free命令中的buffer                            和cache. </p>
<p>kbcached 缓存的文件大小</p>
<p>kbcommit  保证当前系统正常运行所需要的最小内存，即为了确保内存不溢出而需要的最少内存（物理内存                            +Swap分区）</p>
<p>commt 这个值是kbcommit与内存总量（物理内存+swap分区）的一个百分比的值</p>
<h4 id="pidstat-1"><a href="#pidstat-1" class="headerlink" title="pidstat"></a>pidstat</h4><p>pidstat -r  查看内存使用情况 pidstat将显示各活动进程的内存使用统计</p>
<p>PID：进程标识符</p>
<p>Minflt/s:任务每秒发生的次要错误，不需要从磁盘中加载页</p>
<p>Majflt/s:任务每秒发生的主要错误，需要从磁盘中加载页</p>
<p>VSZ：虚拟地址大小，虚拟内存的使用KB</p>
<p>RSS：常驻集合大小，非交换区五里内存使用KB</p>
<p>Command：task命令名</p>
<h3 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h3><p>磁盘通常是计算机最慢的子系统，也是最容易出现性能瓶颈的地方，因为磁盘离 CPU 距离最远而且 CPU 访问磁盘要涉及到机械操作，比如转轴、寻轨等。访问硬盘和访问内存之间的速度差别是以数量级来计算的，就像1天和1分钟的差别一样。要监测 IO 性能，有必要了解一下基本原理和 Linux 是如何处理硬盘和内存之间的 IO 的。</p>
<p>在理解磁盘IO之前，同样我们需要理解一些概念，例如：</p>
<ul>
<li>文件系统</li>
<li>VFS</li>
<li>文件系统缓存</li>
<li>页缓存page cache</li>
<li>缓冲区高速缓存buffer cache</li>
<li>目录缓存</li>
<li>inode</li>
<li>inode缓存</li>
<li>noop调用策略</li>
</ul>
<h4 id="分析工具-2"><a href="#分析工具-2" class="headerlink" title="分析工具"></a>分析工具</h4><table>
<thead>
<tr>
<th>工具</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>iostat</td>
<td>磁盘详细统计信息</td>
</tr>
<tr>
<td>iotop</td>
<td>按进程查看磁盘IO统计信息</td>
</tr>
<tr>
<td>pidstat</td>
<td>查看每个进程的磁盘IO使用情况</td>
</tr>
</tbody></table>
<h4 id="iostat"><a href="#iostat" class="headerlink" title="iostat"></a>iostat</h4><p>iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况</p>
<img src="/Linux/Linux_performance/iostat.png" alt="image-20200604203027136" style="zoom:55%;">

<p>CPU属性</p>
<p>%user：CPU处在用户模式下的时间百分比。</p>
<p>%nice：CPU处在带NICE值的用户模式下的时间百分比。</p>
<p>%system：CPU处在系统模式下的时间百分比。</p>
<p>%iowait：CPU等待输入输出完成时间的百分比。</p>
<p>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</p>
<p>%idle：CPU空闲时间百分比。</p>
<p>备注：</p>
<p>如果%iowait的值过高，表示硬盘存在I/O瓶颈</p>
<p>如果%idle值高，表示CPU较空闲</p>
<p>如果%idle值高但系统响应慢时，可能是CPU等待分配内存，应加大内存容量。</p>
<p>如果%idle值持续低于10，表明CPU处理能力相对较低，系统中最需要解决的资源是CPU。</p>
<p>Device属性</p>
<p>tps：该设备每秒的传输次数</p>
<p>kB_read/s：每秒从设备（drive expressed）读取的数据量；</p>
<p>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</p>
<p>kB_read： 读取的总数据量；</p>
<p>kB_wrtn：写入的总数量数据量</p>
<p>常用命令：</p>
<p>iostat 2 3 每隔2秒刷新显示，且显示3次</p>
<p>iostat -m 以M为单位显示所有信息</p>
<p>查看设备使用率（%util）、响应时间（await）</p>
<p>iostat -d -x -k 1 1</p>
<h4 id="iotop"><a href="#iotop" class="headerlink" title="iotop"></a>iotop</h4><p>在一般运维工作中经常会遇到这么一个场景，服务器的IO负载很高（iostat中的util），但是无法快速的定位到IO负载的来源进程和来源文件导致无法进行相应的策略来解决问题。</p>
<p>如果你想检查那个进程实际在做 I/O，那么运行 <code>iotop</code> 命令加上 <code>-o</code> 或者 <code>--only</code> 参数。</p>
<p>iotop –only </p>
<h4 id="pidstat-2"><a href="#pidstat-2" class="headerlink" title="pidstat"></a>pidstat</h4><p>显示各个进程的IO使用情况</p>
<p>pidstat -d</p>
<p>报告IO统计显示以下信息：</p>
<ul>
<li>PID：进程id</li>
<li>kB_rd/s：每秒从磁盘读取的KB</li>
<li>kB_wr/s：每秒写入磁盘KB</li>
<li>kB_ccwr/s：任务取消的写入磁盘的KB。当任务截断脏的pagecache的时候会发生。</li>
<li>COMMAND:task的命令名</li>
</ul>
<h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="分析工具-3"><a href="#分析工具-3" class="headerlink" title="分析工具"></a>分析工具</h4><table>
<thead>
<tr>
<th>ping</th>
<th>测试网络的连通性</th>
</tr>
</thead>
<tbody><tr>
<td>netstat</td>
<td>检验本机各端口的网络连接情况</td>
</tr>
<tr>
<td>hostname</td>
<td>查看主机和域名</td>
</tr>
</tbody></table>
<h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>常用命令参数：</p>
<p>-d 使用Socket的SO_DEBUG功能。</p>
<p>-f 极限检测。大量且快速地送网络封包给一台机器，看它的回应。</p>
<p>-n 只输出数值。</p>
<p>-q 不显示任何传送封包的信息，只显示最后的结果。</p>
<p>-r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。</p>
<p>-R 记录路由过程。</p>
<p>-v 详细显示指令的执行过程。</p>
<p>-c 数目：在发送指定数目的包后停止。

</p><p>-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</p>
<p>-I 网络界面：使用指定的网络界面送出数据包。</p>
<p>-l 前置载入：设置在送出要求信息之前，先行发出的数据包。</p>
<p>-p 范本样式：设置填满数据包的范本样式。</p>
<p>-s 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。</p>
<p>-t 存活数值：设置存活数值TTL的大小。</p>
<blockquote>
<p>ping -b 192.168.120.1   –ping网关</p>
<p>ping -c 10 192.168.120.206  –ping指定次数</p>
<p>ping -c 10 -i 0.5 192.168.120.206   –时间间隔和次数限制的ping</p>
</blockquote>
<h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>netstat命令是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。</p>
<p>netstat [选项]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-a或--all：显示所有连线中的Socket； </span><br><span class="line">-a (all) 显示所有选项，默认不显示LISTEN相关。</span><br><span class="line">-t (tcp) 仅显示tcp相关选项。</span><br><span class="line">-u (udp) 仅显示udp相关选项。</span><br><span class="line">-n 拒绝显示别名，能显示数字的全部转化成数字。</span><br><span class="line">-l 仅列出有在 Listen (监听) 的服务状态。</span><br><span class="line">-p 显示建立相关链接的程序名</span><br><span class="line">-r 显示路由信息，路由表</span><br><span class="line">-e 显示扩展信息，例如uid等</span><br><span class="line">-s 按各个协议进行统计</span><br><span class="line">-c 每隔一个固定时间，执行该netstat命令。</span><br></pre></td></tr></table></figure>

<p>常用命令：</p>
<p>列出所有端口情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -a      # 列出所有端口</span><br><span class="line">netstat -at     # 列出所有TCP端口</span><br><span class="line">netstat -au     # 列出所有UDP端口</span><br></pre></td></tr></table></figure>

<p>列出所有处于监听状态的 Sockets</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -l   # 只显示监听端口</span><br><span class="line">netstat -lt  # 显示监听TCP端口</span><br><span class="line">netstat -lu  # 显示监听UDP端口</span><br><span class="line">netstat -lx  # 显示监听UNIX端口</span><br></pre></td></tr></table></figure>

<p>显示每个协议的统计信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -s     # 显示所有端口的统计信息</span><br><span class="line">netstat -st    # 显示所有TCP的统计信息</span><br><span class="line">netstat -su    # 显示所有UDP的统计信息</span><br></pre></td></tr></table></figure>

<p>显示 PID 和进程名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -p</span><br></pre></td></tr></table></figure>

<p>显示网络统计信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -s</span><br></pre></td></tr></table></figure>

<p>统计机器中网络连接各个状态个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat&#96; &#96;-an | &#96;&#96;awk&#96; &#96;&#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for (a in S) print a,S[a]&#125; &#39;</span><br></pre></td></tr></table></figure>

<p><strong>补充netstat网络状态详解：</strong></p>
<p>一个正常的TCP连接，都会有三个阶段:1、TCP三次握手;2、数据传送;3、TCP四次挥手</p>
<img src="/Linux/Linux_performance/tcpconn.png" alt="在这里插入图片描述" style="zoom:40%;">



<p><strong>TCP的连接释放</strong></p>
<img src="/Linux/Linux_performance/tcpclose.png" alt="在这里插入图片描述" style="zoom:80%;">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LISTEN：侦听来自远方的TCP端口的连接请求</span><br><span class="line">SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）</span><br><span class="line">SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态估计被flood攻击了）</span><br><span class="line">ESTABLISHED：代表一个打开的连接</span><br><span class="line">FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认</span><br><span class="line">FIN-WAIT-2：从远程TCP等待连接中断请求</span><br><span class="line">CLOSE-WAIT：等待从本地用户发来的连接中断请求</span><br><span class="line">CLOSING：等待远程TCP对连接中断的确认</span><br><span class="line">LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）</span><br><span class="line">TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认</span><br><span class="line">CLOSED：没有任何连接状态</span><br></pre></td></tr></table></figure>



<hr>
<p>本文参考的文章:</p>
<p> <a href="https://rdc.hundsun.com/portal/article/731.html?ref=myread" target="_blank" rel="noopener">https://rdc.hundsun.com/portal/article/731.html?ref=myread</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL性能优化案例</title>
    <url>/Oracle/SQL/Oracle_SQL_optimization/</url>
    <content><![CDATA[<h1 id="SQL性能优化案例篇"><a href="#SQL性能优化案例篇" class="headerlink" title="SQL性能优化案例篇"></a>SQL性能优化案例篇</h1><h2 id="学会辨别虚假信息"><a href="#学会辨别虚假信息" class="headerlink" title="学会辨别虚假信息"></a>学会辨别虚假信息</h2><p>在日常生活中，我们经常遇到有人说exits比in快，count(1)执行比count(*)快，但事实是真的这样吗？我们自己去进行过实践吗？</p>
<h3 id="in与exist之争"><a href="#in与exist之争" class="headerlink" title="in与exist之争"></a>in与exist之争</h3><p> 首先创建测试表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> emp <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> dept <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.emp;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> scott.dept;</span><br></pre></td></tr></table></figure>

<p> 在Oracle 11g中执行并查看执行计划：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> deptno <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">select</span> deptno <span class="keyword">from</span> emp ) ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> ( <span class="keyword">select</span> deptno <span class="keyword">from</span> emp <span class="keyword">where</span>     emp.deptno=dept.deptno) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt; set autotrace traceonly;</span><br><span class="line">SQL&gt; select * from dept where deptno NOT IN ( select deptno from emp ) ;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt; set autotrace traceonly</span><br><span class="line">SQL&gt; select * from dept where deptno NOT IN ( select deptno from emp where deptno is not null) and deptno is not null;</span><br></pre></td></tr></table></figure>

<p>我们发现两个语句的效率是一样的，查看执行计划也是一样的。原来oracle在11g中已经做了优化，所以in和exist的效率是一样的。</p>
<p>由此我们可以得出结论，在11g中，使用in和exist的效率是一样的，因为他们走的都是比较高效的ANTI算法。而网上所说的in慢于exist是在10g的时候会出现的情况，因为10g的时候在不指定列为非空的情况下，in走的是filter的算法，现对于anti半连接算法比较低效，但是在10g当中sql语句指定不为空，也可走anti算法。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dept <span class="keyword">where</span> deptno <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">select</span> deptno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>) <span class="keyword">and</span> deptno <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h3 id="count谁最快"><a href="#count谁最快" class="headerlink" title="count谁最快"></a>count谁最快</h3><p> 首先创建测试表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">test</span> <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">test</span> <span class="keyword">set</span> object_id =<span class="keyword">rownum</span> ;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<p>  在无索引的情况下，比较count(*)与count(object_id)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看执行时间</span></span><br><span class="line">SQL&gt; set timing on </span><br><span class="line">SQL&gt; set autotrace traceonly; </span><br><span class="line">SQL&gt; select count(*) from test;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SQL&gt; select count(object_id) from test;</span><br></pre></td></tr></table></figure>

<p>我们在列object_id上创建索引，再次比较count(*)与count(object_id)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_object_id <span class="keyword">on</span> <span class="keyword">test</span>(object_id);</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt; select count(*) from test;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt; select count(object_id) from test;</span><br></pre></td></tr></table></figure>

<p>发现count(object_id)的速度明显比count(*)高出一大截，难道是因为count(object_id)能用到索引，所以效率才提高了很多？</p>
<p>我们再修改下object_id的列属性，再次比较count(*)与count(object_id)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt; select count(*) from test;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">SQL&gt; select count(object_id) from test;</span><br></pre></td></tr></table></figure>

<p>结论：</p>
<p>1）对于上述实验来说，在一个无任何索引的表中count(*)与count(object_id)的性能是一样的；</p>
<p>2）在某一列有索引但此列可为空的前提下，count(*)比count(object_id)慢，因为count(object_id)用到了索引；</p>
<p>3）在某一列有索引但此列不为空的前提下count(*)与count(object_id)的性能是一样的；</p>
<p>另在没有索引的情况下，对不同的列做实验发现：</p>
<img src="/Oracle/SQL/Oracle_SQL_optimization/sql.png" alt="sql.ping" style="zoom:80%;">

<p>对于oracle优化器来说，count不同的列，统计的时间是不一样的，大致趋势是列越靠后，访问的开销越大，列的偏移量决定访问的性能。而count(*)的开销与偏移量无关。</p>
<p>因此，在某些场合count(*)反而是最快的。</p>
<h3 id="表的条件顺序"><a href="#表的条件顺序" class="headerlink" title="表的条件顺序"></a>表的条件顺序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t1 <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t2 <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">id</span> ,dbms_random.string(<span class="string">'b'</span>, <span class="number">50</span>) n ,data_object_id data_id <span class="keyword">from</span> dba_objects <span class="keyword">where</span> <span class="keyword">rownum</span>&lt;=<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+rule*/</span> * <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t1.object_id=<span class="number">29</span> <span class="keyword">and</span> t2.data_id&gt;<span class="number">8</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+rule*/</span> * <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t2.data_id&gt;<span class="number">8</span> <span class="keyword">and</span> t1.object_id=<span class="number">29</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--加个关联条件看看，看看</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+rule*/</span> * <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t1.object_id=t2.id <span class="keyword">and</span> t1.object_id=<span class="number">29</span> <span class="keyword">and</span> t2.data_id&gt;<span class="number">8</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+rule*/</span> * <span class="keyword">from</span> t1,t2 <span class="keyword">where</span> t1.object_id=t2.id <span class="keyword">and</span> t2.data_id&gt;<span class="number">8</span> <span class="keyword">and</span> t1.object_id=<span class="number">29</span> ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：通过上述实验发现，无论有过滤条件的WHERE放在后面还是放在前面，效果是一样的。因此，关于有过滤条件的WHERE放在后面的说法是错误的。</p>
</blockquote>
<h3 id="表的连接顺序"><a href="#表的连接顺序" class="headerlink" title="表的连接顺序"></a>表的连接顺序</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--来来来，做一个试验，看看SQL写法中，表的连接顺序是否很重要</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tab_big;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tab_small;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_big  <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tab_small  <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects <span class="keyword">where</span> <span class="keyword">rownum</span>&lt;=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tab_big,tab_small   ;  </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tab_small,tab_big   ;</span><br><span class="line"><span class="comment">---奇怪，以上实验发现性能是一样的，咋回事呢，看来真是谣言啊，这真是恶意传谣吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">---大家看看下面的语句，比较一下性能。</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+rule*/</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tab_big,tab_small ;  </span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+rule*/</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tab_small,tab_big ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：原来表连接顺序的说法早就过时了，在基于规则的时代，小表在后，大表在前确实性能高于小表在前大表在后，现在oracle是基于代价的。性能是一样的。</p>
</blockquote>
<h2 id="索引优化的优劣"><a href="#索引优化的优劣" class="headerlink" title="索引优化的优劣"></a>索引优化的优劣</h2><h3 id="索引的优势"><a href="#索引的优势" class="headerlink" title="索引的优势"></a>索引的优势</h3><h4 id="索引优化之回表"><a href="#索引优化之回表" class="headerlink" title="索引优化之回表"></a>索引优化之回表</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--索引回表读（TABLE ACCESS BY INDEX ROWID）的例子</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="comment">--只建一个主键索引，查询所有字段*</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx1_object_id <span class="keyword">on</span> t(object_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">--试验1</span></span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> object_id&lt;=<span class="number">5</span>;</span><br><span class="line"><span class="comment">--试验2</span></span><br><span class="line"><span class="comment">--比较消除TABLE ACCESS BY INDEX ROWID回表后的性能，将select * from改为select object_id from </span></span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span></span><br><span class="line"><span class="keyword">select</span> object_id <span class="keyword">from</span> t <span class="keyword">where</span> object_id&lt;=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--试验3：通过构造联合索引，再观察一个消除TABLE ACCESS BY INDEX ROWID的例子</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_un_objid_objname <span class="keyword">on</span> t(object_id,object_name);</span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span></span><br><span class="line"><span class="keyword">select</span> object_id,object_name <span class="keyword">from</span> t <span class="keyword">where</span> object_id&lt;=<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：通过观察执行计划，我们发现当不回表的时候，性能更好，因为只在索引当中就查到了我们想要的字段。</p>
</blockquote>
<h4 id="索引优化之索引的高度"><a href="#索引优化之索引的高度" class="headerlink" title="索引优化之索引的高度"></a>索引优化之索引的高度</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span> ,<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> id2,rpad(<span class="string">'*'</span>,<span class="number">1000</span>,<span class="string">'*'</span>) <span class="keyword">as</span> <span class="keyword">contents</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span> ,<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> id2,rpad(<span class="string">'*'</span>,<span class="number">1000</span>,<span class="string">'*'</span>) <span class="keyword">as</span> <span class="keyword">contents</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span> ,<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> id2,rpad(<span class="string">'*'</span>,<span class="number">1000</span>,<span class="string">'*'</span>) <span class="keyword">as</span> <span class="keyword">contents</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">200</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t4 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span> ,<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> id2,rpad(<span class="string">'*'</span>,<span class="number">1000</span>,<span class="string">'*'</span>) <span class="keyword">as</span> <span class="keyword">contents</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">2000</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t5 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span> ,<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> id2,rpad(<span class="string">'*'</span>,<span class="number">1000</span>,<span class="string">'*'</span>) <span class="keyword">as</span> <span class="keyword">contents</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">20000</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t6 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span> ,<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> id2,rpad(<span class="string">'*'</span>,<span class="number">1000</span>,<span class="string">'*'</span>) <span class="keyword">as</span> <span class="keyword">contents</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">200000</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t7 <span class="keyword">as</span> <span class="keyword">select</span> <span class="keyword">rownum</span> <span class="keyword">as</span> <span class="keyword">id</span> ,<span class="keyword">rownum</span>+<span class="number">1</span> <span class="keyword">as</span> id2,rpad(<span class="string">'*'</span>,<span class="number">1000</span>,<span class="string">'*'</span>) <span class="keyword">as</span> <span class="keyword">contents</span> <span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">level</span>&lt;=<span class="number">2000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_id_t1 <span class="keyword">on</span> t1(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_id_t2 <span class="keyword">on</span> t2(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_id_t3 <span class="keyword">on</span> t3(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_id_t4 <span class="keyword">on</span> t4(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_id_t5 <span class="keyword">on</span> t5(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_id_t6 <span class="keyword">on</span> t6(<span class="keyword">id</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_id_t7 <span class="keyword">on</span> t7(<span class="keyword">id</span>);</span><br><span class="line"><span class="comment">--观察索引的高度的不同</span></span><br><span class="line"><span class="keyword">select</span> index_name,<span class="comment">--索引名字</span></span><br><span class="line">          blevel,<span class="comment">--索引高度</span></span><br><span class="line">          leaf_blocks,<span class="comment">--索引叶子占用块</span></span><br><span class="line">          num_rows,<span class="comment">--行数</span></span><br><span class="line">          distinct_keys,</span><br><span class="line">          clustering_factor</span><br><span class="line">     <span class="keyword">from</span> user_ind_statistics</span><br><span class="line">    <span class="keyword">where</span> table_name <span class="keyword">in</span>( <span class="string">'T1'</span>,<span class="string">'T2'</span>,<span class="string">'T3'</span>,<span class="string">'T4'</span>,<span class="string">'T5'</span>,<span class="string">'T6'</span>,<span class="string">'T7'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--执行    </span></span><br><span class="line"><span class="keyword">set</span> autotrace traceonly <span class="keyword">statistics</span></span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="comment">--注意观察逻辑读的次数，另外每条语句执行2遍以上，观察第2遍的结果。为了消除物理读以及递归调用。</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t5 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t6 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t7 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"><span class="comment">--观察全表扫描的结果</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+full(t1)*/</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+full(t2)*/</span> * <span class="keyword">from</span> t2 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+full(t3)*/</span> * <span class="keyword">from</span> t3 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+full(t4)*/</span> * <span class="keyword">from</span> t4 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+full(t5)*/</span> * <span class="keyword">from</span> t5 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+full(t6)*/</span> * <span class="keyword">from</span> t6 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">select</span> <span class="comment">/*+full(t7)*/</span> * <span class="keyword">from</span> t7 <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：当索引的高度相同时，使用索引查询，发现产生逻辑读的次数一般相同；而使用全表扫描的差异巨大。但是请注意这是建立在返回一条数据或者少数数据的前体下，如果返回大量的数据，使用索引反而比使用全表扫描更慢。另外，在本案例中，大家也许觉得两百万数据量在全表扫描时执行速度也很快，那是因为这些表字段很少，oracle不会占用很多的数据块，当表的字段同样类型的增加到40个乃至更多，速度自然而然就慢了，因为遍历的块更多了。所以我们有时可以删除一些不需要的字段从而使某些需要全表扫描的场合性能提高。</p>
</blockquote>
<h4 id="索引优化之count，sum，avg"><a href="#索引优化之count，sum，avg" class="headerlink" title="索引优化之count，sum，avg"></a>索引优化之count，sum，avg</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> object_id=<span class="keyword">rownum</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx1_object_id <span class="keyword">on</span> t(object_id);</span><br><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">on</span></span><br><span class="line"><span class="comment">--此时走的是全表扫描</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t;</span><br><span class="line"><span class="comment">--此时走的是索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t <span class="keyword">where</span> object_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">--也可以不加is not null，直接把列的属性设置为not null，也成，继续试验如下：</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">modify</span> OBJECT_ID <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> t;</span><br><span class="line"><span class="comment">--如果是主键就无需定义列是否允许为空了。因为主键本身就不能为空，此时也可走索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--sum以及avg同样的套路，可以自行实验，至少在11g当中是这样</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：当我们在使用count函数，或者是sum以及avg聚合函数时，当此列有索引的时候，要注意此列的取值是否可为空，这关系到是否使用索引；当没有索引时，根据实际情况考虑是否添加索引。</p>
</blockquote>
<h4 id="索引优化之distinct"><a href="#索引优化之distinct" class="headerlink" title="索引优化之distinct"></a>索引优化之distinct</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> object_id=<span class="keyword">rownum</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">modify</span> OBJECT_ID <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> object_id=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> object_id=<span class="number">3</span> <span class="keyword">where</span> <span class="keyword">rownum</span>&lt;=<span class="number">25000</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="comment">--测试1</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> object_id <span class="keyword">from</span> t ;</span><br><span class="line"><span class="comment">--测试2</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t_object_id <span class="keyword">on</span> t(object_id);</span><br><span class="line"><span class="keyword">select</span>  <span class="comment">/*+index(t)*/</span> <span class="keyword">distinct</span> object_id <span class="keyword">from</span> t ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：经测试发现，执行计划当中并没有显示其发生了排序操作，那是因为在oracle10g的R2环境之后，DISTINCT由于其 HASH UNIQUE的算法导致其不会产生排序，不过虽然没有排序，通过观察执行计划当中的TempSpc可知distinct消耗PGA内存进行HASH UNIQUE运算；接下来看看建了索引后的情况，TempSpc关键字并没有消失，因此网上许多所说的会消失是不正确的，至少在oracle11g（11.2.0.1.0）当中并没有消失，但是COST确实下降许多；不过在现实中，DISTINCT往往靠索引来优化效果并不是很明显，因为大多数用到DISTINCT的地方是因为我们的表中有重复记录，因此，我们一般首先要考虑的是为什么会重复。</p>
</blockquote>
<h4 id="索引优化之union"><a href="#索引优化之union" class="headerlink" title="索引优化之union"></a>索引优化之union</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">----UNION 是需要排序的</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t1 <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects <span class="keyword">where</span> object_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">modify</span> OBJECT_ID <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t2 <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects <span class="keyword">where</span> object_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t2 <span class="keyword">modify</span> OBJECT_ID <span class="keyword">not</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> object_id <span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> object_id <span class="keyword">from</span> t2;</span><br><span class="line"></span><br><span class="line"><span class="comment">--发现索引无法消除UNION 排序</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t1_object_id <span class="keyword">on</span> t1(object_id);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t2_object_id <span class="keyword">on</span> t2(object_id);</span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  object_id <span class="keyword">from</span> t1</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span>  object_id <span class="keyword">from</span> t2;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：使用UNION是会产生排序的，使用索引无法消除UNION 排序，因此我们在使用的时候要确定是否有使用的 必要，如果表中没有重复记录，则使用UNION ALL即可。</p>
</blockquote>
<h4 id="索引优化之order-by"><a href="#索引优化之order-by" class="headerlink" title="索引优化之order by"></a>索引优化之order by</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects ;</span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="comment">--以下语句没有索引又有order by ，必然产生排序</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> object_id&gt;<span class="number">2</span> <span class="keyword">order</span> <span class="keyword">by</span> object_id;</span><br><span class="line"><span class="comment">---新增索引后，Oracle就有可能利用索引本身就有序的特点，利用索引来避免排序，如下：</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t_object_id <span class="keyword">on</span> t(object_id);</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="keyword">where</span> object_id&gt;<span class="number">2</span> <span class="keyword">order</span> <span class="keyword">by</span> object_id;</span><br><span class="line"><span class="comment">--如下情况Oracle肯定毫不犹豫的选择用索引,因为回表取消了 !      </span></span><br><span class="line"><span class="keyword">select</span>  object_id <span class="keyword">from</span> t <span class="keyword">where</span> object_id&gt;<span class="number">2</span> <span class="keyword">order</span> <span class="keyword">by</span> object_id;</span><br><span class="line"><span class="comment">--如下情况，就算有索引，oracle也不会用索引</span></span><br><span class="line"><span class="keyword">select</span>  object_id <span class="keyword">from</span> t <span class="keyword">where</span> object_id&gt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="索引的劣势"><a href="#索引的劣势" class="headerlink" title="索引的劣势"></a>索引的劣势</h3><h4 id="位图索引遭遇更新苦不堪言"><a href="#位图索引遭遇更新苦不堪言" class="headerlink" title="位图索引遭遇更新苦不堪言"></a>位图索引遭遇更新苦不堪言</h4><p>测试数据准备</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t </span><br><span class="line">(name_id,</span><br><span class="line"> gender <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> location <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> age_group <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"> <span class="keyword">data</span></span><br><span class="line"> )</span><br><span class="line"> <span class="keyword">as</span></span><br><span class="line"> <span class="keyword">select</span> <span class="keyword">rownum</span>,</span><br><span class="line">        <span class="keyword">decode</span>(<span class="keyword">ceil</span>(dbms_random.value(<span class="number">0</span>,<span class="number">2</span>)),</span><br><span class="line">               <span class="number">1</span>,<span class="string">'M'</span>,</span><br><span class="line">               <span class="number">2</span>,<span class="string">'F'</span>)gender,</span><br><span class="line">        <span class="keyword">ceil</span>(dbms_random.value(<span class="number">1</span>,<span class="number">50</span>)) location,</span><br><span class="line">        <span class="keyword">decode</span>(<span class="keyword">ceil</span>(dbms_random.value(<span class="number">0</span>,<span class="number">3</span>)),</span><br><span class="line">               <span class="number">1</span>,<span class="string">'child'</span>,</span><br><span class="line">               <span class="number">2</span>,<span class="string">'young'</span>,</span><br><span class="line">               <span class="number">3</span>,<span class="string">'middle_age'</span>,</span><br><span class="line">               <span class="number">4</span>,<span class="string">'old'</span>),</span><br><span class="line">         rpad(<span class="string">'*'</span>,<span class="number">400</span>,<span class="string">'*'</span>)</span><br><span class="line"><span class="keyword">from</span> dual <span class="keyword">connect</span> <span class="keyword">by</span> <span class="keyword">rownum</span>&lt;=<span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">bitmap</span> <span class="keyword">index</span> gender_idx <span class="keyword">on</span> t(gender);</span><br><span class="line"><span class="comment">---实验一：</span></span><br><span class="line"><span class="comment">--SESSION 1 不提交</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(name_id,gender,location ,age_group ,<span class="keyword">data</span>) <span class="keyword">values</span> (<span class="number">100001</span>,<span class="string">'M'</span>,<span class="number">45</span>,<span class="string">'child'</span>,rpad(<span class="string">'*'</span>,<span class="number">20</span>,<span class="string">'*'</span>));</span><br><span class="line"><span class="comment">--SESSION 2</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(name_id,gender,location ,age_group ,<span class="keyword">data</span>) <span class="keyword">values</span> (<span class="number">100002</span>,<span class="string">'M'</span>,<span class="number">46</span>, <span class="string">'young'</span>, rpad(<span class="string">'*'</span>,<span class="number">20</span>,<span class="string">'*'</span>));</span><br><span class="line"><span class="comment">---实验二：</span></span><br><span class="line"><span class="comment">--SESSION 1（持有者）</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> GENDER=<span class="string">'M'</span> <span class="keyword">AND</span> LOCATION=<span class="number">25</span>;</span><br><span class="line"><span class="comment">---SESSION 2(其他会话) 插入带M的记录就立即被阻挡，以下三条语句都会被阻止</span></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> t (name_id,gender,location ,age_group ,<span class="keyword">data</span>) <span class="keyword">values</span> (<span class="number">100001</span>,<span class="string">'M'</span>,<span class="number">78</span>, <span class="string">'young'</span>,<span class="string">'TTT'</span>);</span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> gender=<span class="string">'M'</span> <span class="keyword">WHERE</span> LOCATION=<span class="number">25</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> T <span class="keyword">WHERE</span> GENDER=<span class="string">'M'</span>;</span><br><span class="line"><span class="comment">--实验三：</span></span><br><span class="line"><span class="comment">--SESSION 1（持有者）</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> GENDER=<span class="string">'M'</span> <span class="keyword">AND</span> LOCATION=<span class="number">25</span>;</span><br><span class="line"><span class="comment">---SESSION 2(其他会话)</span></span><br><span class="line"><span class="comment">--以下是可以进行不受阻碍的</span></span><br><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> t (name_id,gender,location ,age_group ,<span class="keyword">data</span>) <span class="keyword">values</span> (<span class="number">100001</span>,<span class="string">'F'</span>,<span class="number">78</span>, <span class="string">'young'</span>,<span class="string">'TTT'</span>);</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span>  t <span class="keyword">where</span> gender=<span class="string">'F'</span> ;</span><br><span class="line"><span class="keyword">UPDATE</span> T <span class="keyword">SET</span> LOCATION=<span class="number">100</span> <span class="keyword">WHERE</span> <span class="keyword">ROWID</span> <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="keyword">ROWID</span> <span class="keyword">FROM</span> T <span class="keyword">WHERE</span> GENDER=<span class="string">'F'</span> <span class="keyword">AND</span> LOCATION=<span class="number">25</span>) ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：当你对于某一张表的一个字段加了位图索引之后，对于此表的操作，目前可以说几乎只能是单进程单用户操作了，这样的操作显然不支持高并发，对于整体系统并没有好处。因此要注意位图索引的使用场景。</p>
</blockquote>
<h4 id="建索引过程会产生全表锁"><a href="#建索引过程会产生全表锁" class="headerlink" title="建索引过程会产生全表锁"></a>建索引过程会产生全表锁</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t <span class="keyword">purge</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="comment">--尽可能插入多点数据，不然操作太快来不及发现</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t  <span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t  <span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t  <span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t  <span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t  <span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t  <span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t  <span class="keyword">select</span> * <span class="keyword">from</span> t;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--SESSION 1</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_object_id <span class="keyword">on</span> t(object_id);</span><br><span class="line"><span class="comment">--SESSION 2</span></span><br><span class="line"><span class="keyword">update</span> t <span class="keyword">set</span> object_id=<span class="number">99999</span> <span class="keyword">where</span> object_id=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> object_id=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span>  t (OWNER) <span class="keyword">values</span> (<span class="string">'111'</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：经上述实验可得，普通的对表建索引将会导致针对该表的更新操作无法进行，需要等待索引建完。更新操作将会被建索引动作阻塞。SESSION2 的三个操作，均需要SESSION1的索引建完之后才能执行。因此，在我们平时建索引的时候，尤其是对于一些大表在生产系统建立索引的时候一定要在夜里业务不繁忙的时候进行。</p>
</blockquote>
<h4 id="索引过多影响插入"><a href="#索引过多影响插入" class="headerlink" title="索引过多影响插入"></a>索引过多影响插入</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test2 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test3 <span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_owner <span class="keyword">on</span> test1(owner);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_object_name <span class="keyword">on</span> test1(object_name);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_data_obj_id <span class="keyword">on</span> test1(data_object_id);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_created <span class="keyword">on</span> test1(created);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_last_ddl_time <span class="keyword">on</span> test1(last_ddl_time);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_status <span class="keyword">on</span> test1(<span class="keyword">status</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t2_sta <span class="keyword">on</span> test2(<span class="keyword">status</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t2_objid <span class="keyword">on</span> test2(object_id);</span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span> </span><br><span class="line"><span class="comment">--语句1(test1表有6个索引）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test1 <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">--语句2(test2表有2个索引）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test2 <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="comment">--语句3(test3表有无索引）</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test3 <span class="keyword">select</span> * <span class="keyword">from</span> dba_objects;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：索引越多，插入速度越慢。因为有了索引，更新了记录就更新了索引，就要维护索引那种有序排列的结构，开销比较大。因此我们在项目中建索引要考虑全面，并且建索引要规范。而我们在项目中若遇到大批量的向大表中插入数据时，我们可以先禁用索引，插入完成之后再重建索引，这样效率会比有索引插入快。因为此时重建索引是一个批量的动作，而不是单次插入单次维护索引。</p>
</blockquote>
<h2 id="表连接优化"><a href="#表连接优化" class="headerlink" title="表连接优化"></a>表连接优化</h2><h4 id="NL连接（Nest-Loop）"><a href="#NL连接（Nest-Loop）" class="headerlink" title="NL连接（Nest Loop）"></a>NL连接（Nest Loop）</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t1 <span class="keyword">CASCADE</span> <span class="keyword">CONSTRAINTS</span> <span class="keyword">PURGE</span>; </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t2 <span class="keyword">CASCADE</span> <span class="keyword">CONSTRAINTS</span> <span class="keyword">PURGE</span>; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">     <span class="keyword">id</span> <span class="built_in">NUMBER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     n <span class="built_in">NUMBER</span>,</span><br><span class="line">     <span class="keyword">contents</span> <span class="built_in">VARCHAR2</span>(<span class="number">4000</span>)); </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line">     <span class="keyword">id</span> <span class="built_in">NUMBER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     t1_id <span class="built_in">NUMBER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     n <span class="built_in">NUMBER</span>,</span><br><span class="line">     <span class="keyword">contents</span> <span class="built_in">VARCHAR2</span>(<span class="number">4000</span>)); </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">SELECT</span> <span class="keyword">rownum</span>,<span class="keyword">rownum</span>, dbms_random.string(<span class="string">'a'</span>, <span class="number">50</span>) <span class="keyword">FROM</span> dual  <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">level</span> &lt;= <span class="number">10000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> dbms_random.random; </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2 <span class="keyword">SELECT</span> <span class="keyword">rownum</span>, <span class="keyword">rownum</span>, <span class="keyword">rownum</span>, dbms_random.string(<span class="string">'b'</span>, <span class="number">50</span>) <span class="keyword">FROM</span> dual <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">level</span> &lt;= <span class="number">1000000</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> dbms_random.random; </span><br><span class="line"><span class="keyword">COMMIT</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t1) use_nl(t2) */</span> * <span class="keyword">FROM</span> t1,t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">AND</span> t1.n= <span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="comment">--收集统计信息.</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> statistics_level=<span class="keyword">all</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">---1.对t1表的限制条件建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> t1_n <span class="keyword">ON</span> t1 (n);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t1) use_nl(t2) */</span> * <span class="keyword">FROM</span> t1,t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">AND</span> t1.n= <span class="number">19</span></span><br><span class="line"><span class="comment">--查看执行计划</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">---2.在1的基础上对被驱动表t2表的连接条件建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> t2_t1_id <span class="keyword">ON</span> t2(t1_id);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t1) use_nl(t2) */</span> * <span class="keyword">FROM</span> t1,t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">AND</span> t1.n= <span class="number">19</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">---3.确保小结果集先驱动</span></span><br><span class="line"><span class="comment">--我们构造如下：假如oracle的统计信息不准确</span></span><br><span class="line"><span class="comment">--以下故意错乱颠倒，欺骗Oracle说T1表是大表而T2表是小表。</span></span><br><span class="line">EXEC  dbms_stats.SET_table_stats(user, 'T1', numrows =&gt; 20000000  ,numblks =&gt; 1000000);</span><br><span class="line">EXEC  dbms_stats.SET_table_stats(user, 'T2', numrows =&gt; 1  ,numblks =&gt; 1);</span><br><span class="line"><span class="comment">--此时t2表为驱动表，t1表为被驱动表，此时发现性能大幅度下降</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id  t2.t1_id <span class="keyword">AND</span> t1.n &lt;= <span class="number">19</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：通过以上实验的执行计划可以看出，当使用NL连接的时候，我们保证以上三点，会使sql达到比较好的性能。</p>
<p>为什么在嵌套循环的驱动表的限制条件建索引,被驱动表的连接条件建索引？<br>驱动表的限制条件建索引的目的是为了减少扫描驱动表的时间。如果在驱动表的连接条件建索引就没有任何意义，所有列关联到另一表的所有列，等同于每条记录都要进行关联，而在驱动表的限制条件建了索引之后，只快速返回一条或者几条记录，然后在传递给被驱动表的连接条件列，一般情况下被驱动表对应的驱动表的记录返回的不多，所以在被驱动表的连接条件建立索引是有必要的。</p>
</blockquote>
<h4 id="HASH-JOIN连接"><a href="#HASH-JOIN连接" class="headerlink" title="HASH JOIN连接"></a>HASH JOIN连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--环境构造</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t1 <span class="keyword">CASCADE</span> <span class="keyword">CONSTRAINTS</span> <span class="keyword">PURGE</span>; </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> t2 <span class="keyword">CASCADE</span> <span class="keyword">CONSTRAINTS</span> <span class="keyword">PURGE</span>; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (</span><br><span class="line">     <span class="keyword">id</span> <span class="built_in">NUMBER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     n <span class="built_in">NUMBER</span>,</span><br><span class="line">     <span class="keyword">contents</span> <span class="built_in">VARCHAR2</span>(<span class="number">4000</span>)</span><br><span class="line">   ); </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line">     <span class="keyword">id</span> <span class="built_in">NUMBER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     t1_id <span class="built_in">NUMBER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">     n <span class="built_in">NUMBER</span>,</span><br><span class="line">     <span class="keyword">contents</span> <span class="built_in">VARCHAR2</span>(<span class="number">4000</span>)</span><br><span class="line">   );  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t1 <span class="keyword">SELECT</span>  <span class="keyword">rownum</span>,  <span class="keyword">rownum</span>, dbms_random.string(<span class="string">'a'</span>, <span class="number">50</span>) <span class="keyword">FROM</span> dual </span><br><span class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">level</span> &lt;= <span class="number">10000</span></span><br><span class="line">      <span class="keyword">ORDER</span> <span class="keyword">BY</span> dbms_random.random; </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t2 <span class="keyword">SELECT</span> <span class="keyword">rownum</span>, <span class="keyword">rownum</span>, <span class="keyword">rownum</span>, dbms_random.string(<span class="string">'b'</span>, <span class="number">50</span>) <span class="keyword">FROM</span> dual <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">level</span> &lt;= <span class="number">100000</span></span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> dbms_random.random; </span><br><span class="line"><span class="keyword">COMMIT</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">--1.两表的限制条件有索引(注：针对索引条件返回记录很少的情况）！</span></span><br><span class="line"><span class="comment">--首先测试Hash Join两表的限制条件皆无索引的情况</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> statistics_level=<span class="keyword">all</span> ;</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t2) use_hash(t1)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">and</span> t1.n=<span class="number">19</span> <span class="keyword">and</span> t2.n=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"><span class="comment">--在t1表的限制条件建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t1_n <span class="keyword">on</span> t1(n);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t2) use_hash(t1)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">and</span> t1.n=<span class="number">19</span> <span class="keyword">and</span> t2.n=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"><span class="comment">--在t2表的限制条件建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t2_n <span class="keyword">on</span> t2(n);   </span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t2) use_hash(t1)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">and</span> t1.n=<span class="number">19</span> <span class="keyword">and</span> t2.n=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"><span class="comment">--2.确保小结果集先驱动</span></span><br><span class="line"><span class="comment">--t1为驱动表</span></span><br><span class="line"><span class="keyword">SELECT</span>  * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"><span class="comment">--t2为驱动表</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="comment">/*+ leading(t2) use_hash(t1)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"><span class="comment">--结论：在2的实验中发现，虽然buffers的变化可能很小甚至一样，但是userd-mem却差异比较明显。说明排序尺寸差异明显。在结合时间发现，两者的时间差异也比较明显。大表为驱动表所耗时间较长。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--3.确保PGA尺寸足够</span></span><br><span class="line"><span class="comment">--因为HASH JOIN连接会使用到PGA内存区域的hash area，若内存不够，会用到磁盘的空间。</span></span><br></pre></td></tr></table></figure>

<h4 id="Merge-Sort-Join连接"><a href="#Merge-Sort-Join连接" class="headerlink" title="Merge Sort Join连接"></a>Merge Sort Join连接</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--环境构造同上hash join</span></span><br><span class="line"><span class="comment">--1.两表的限制条件有索引</span></span><br><span class="line"><span class="comment">--两表限制条件皆无索引的情况</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">set</span> statistics_level=<span class="keyword">all</span> ;</span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t2) use_merge(t1)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">and</span> t1.n=<span class="number">19</span> <span class="keyword">and</span> t2.n=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"><span class="comment">--t1表的限制条件建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t1_n <span class="keyword">on</span> t1(n);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t2) use_merge(t1)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">and</span> t1.n=<span class="number">19</span> <span class="keyword">and</span> t2.n=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"><span class="comment">--t2表的限制条件建索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_t2_n <span class="keyword">on</span> t2(n);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t2) use_merge(t1)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id <span class="keyword">and</span> t1.n=<span class="number">19</span> <span class="keyword">and</span> t2.n=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="literal">null</span>,<span class="literal">null</span>,<span class="string">'allstats last'</span>));</span><br><span class="line"><span class="comment">--2.连接字段有索引，争取利用索引来消除排序（可惜的是，在11g以及之前版本，ORACLE算法的限制，只能避免一次排序，后续版本未知，需要试验）</span></span><br><span class="line"><span class="comment">--两表的连接条件都无索引的情况，有两次排序：</span></span><br><span class="line"><span class="keyword">set</span> linesize <span class="number">1000</span></span><br><span class="line"><span class="keyword">set</span> autotrace traceonly</span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t1) use_merge(t2)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id;</span><br><span class="line"><span class="comment">--t1表建索引，发现排序消除了一个</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t1_id <span class="keyword">ON</span> t1(<span class="keyword">id</span>); </span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t1) use_merge(t2)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id;</span><br><span class="line"><span class="comment">--在t2表的连接条件建索引，发现排序依然有一个，无法消除</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_t2_t1_id <span class="keyword">ON</span> t2(t1_id);   </span><br><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ leading(t1) use_merge(t2)*/</span> * <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id = t2.t1_id;</span><br><span class="line"><span class="comment">--3.避免多余列致排序尺寸过大（取部分字段）</span></span><br><span class="line"><span class="comment">--对于NL以及hash连接来说，只取部分列性能基本不会有什么变化</span></span><br><span class="line"><span class="comment">--4.确保PGA尺寸足够</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Oracle</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的了解“SQL”吗？</title>
    <url>/Oracle/SQL-Oracle/</url>
    <content><![CDATA[<h1 id="SQL优化思路-Oracle篇"><a href="#SQL优化思路-Oracle篇" class="headerlink" title="SQL优化思路-Oracle篇"></a>SQL优化思路-Oracle篇</h1><p><strong>为什么要重点提及SQL优化？</strong></p>
<p>关于SQL优化的教程很多，也是结合了各种资料以及书籍进行整理。下面给大家分享一下。</p>
<p>作为程序员经常和数据库打交道的时候还是非常频繁的，掌握住一些Sql的优化技巧还是非常有必要的。下面列出一些常用的SQl优化技巧。</p>
<p><code>在工作中发现在数据库方面的一些现象</code>：</p>
<ol>
<li><p><strong>开发人员将数据库视为“黑盒子”</strong>，开发人员不关心，不重视SQL的执行过程，只关注具体的应用层体现。</p>
</li>
<li><p><strong>对SQL质量的重视程度不够</strong>,我们在日常项目中通常是不重视SQL的执行,没有经过大数量的反复推敲。</p>
<p>通常是直到项目上线，甚至到出现性能问题时，才会重点关注分析。或者是有DBA介人处理。这种救火模式，往往效果不好，即使有了解决方案，其代价、成本也必然是巨大的。</p>
</li>
<li><p><strong>开发人员想提高，但是无从下手</strong>。有部分开发人员意识到了SQL语句的重要性，但是无从下手。可能只是靠自我的日常积累。导致我们想提高缺困难重重！</p>
</li>
</ol>
<p><code>场景误区</code>：</p>
<ol>
<li><p><strong>关系数据库已死</strong>，近些年来，随着NoSQL的发展盛兴和推广，有一种观点就是关系数据库必将死亡，NoSQL将取而代之！随之而来的就是SQL优化没有必要，NoSQL作为一种新兴的技术，的确有其鲜明的特点，也适用于一些场合。但我们要看到，很多需要ACID的场景下，传统数据库仍然是不二选择，不可取代。</p>
</li>
<li><p><strong>SQL优化很简单</strong>,有些人认为，SQL优化很简单，部分人观点SQL优化不就是加几个索引嘛，有啥难的！</p>
<p>但其不是唯一的。且很多情况下，加了索引可能导致性能更差。在我们真实的项目中观察到单表存在10多个索引的情况。</p>
</li>
<li><p><strong>SQL优化只是DBA的事情</strong>,在我们的开发过程中，只关注自身的业务功能实现而忽略了相应的执行成本。</p>
<p>最终就导致上线后系统运行缓慢，代码质量不够。客户体验较差等问题。</p>
</li>
</ol>
<h2 id="SQL语句的执行顺序"><a href="#SQL语句的执行顺序" class="headerlink" title="SQL语句的执行顺序"></a>SQL语句的执行顺序</h2><blockquote>
<p><strong>SQL Select语句完整的执行顺序</strong></p>
<ol>
<li>from子句组装来自不同数据源的数据；</li>
<li>where子句基于指定的条件对记录行进行筛选；</li>
<li>group by子句将数据划分为多个分组；</li>
<li>使用聚集函数进行计算；</li>
<li>使用having子句筛选分组；</li>
<li>计算所有的表达式；</li>
<li>使用order by对结果集进行排序。</li>
<li>select 集合输出。</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th>语法顺序</th>
<th>加载顺序</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SELECT[DISTINCT]</td>
<td>FROM</td>
</tr>
<tr>
<td>2</td>
<td>FROM</td>
<td>WHERE</td>
</tr>
<tr>
<td>3</td>
<td>WHERE</td>
<td>GROUP BY</td>
</tr>
<tr>
<td>4</td>
<td>GROUP BY</td>
<td>HAVING</td>
</tr>
<tr>
<td>5</td>
<td>HAVING</td>
<td>SELECT</td>
</tr>
<tr>
<td>6</td>
<td>UNION</td>
<td>DISTINCT</td>
</tr>
<tr>
<td>7</td>
<td>ORDER BY</td>
<td>UNION</td>
</tr>
<tr>
<td>8</td>
<td></td>
<td>ORDER BY</td>
</tr>
</tbody></table>
<h2 id="理解SQL执行原理和过程"><a href="#理解SQL执行原理和过程" class="headerlink" title="理解SQL执行原理和过程"></a>理解SQL执行原理和过程</h2><ul>
<li><p><strong>客户端把语句发给服务器端执行</strong></p>
<p>​        当我们在客户端执行 select 语句时,客户端会把这条 SQL 语句发送给服务器端,让服务器端的进程来处理这语句。</p>
</li>
<li><p><strong>语句解析</strong></p>
<blockquote>
<ol>
<li>查询高速缓存(library cache)。服务器进程在接到客户端传送过来的 SQL 语句时,不会直接去数据库查询。而是会先在数据库的高速缓存中去查找,是否存在相同语句的执行计划。如果在数据高速缓存中,则服务器进程就会直接执行这个 SQL 语句,省去后续的工作。所以,采用高速数据缓存的话,可以提高 SQL 语句的查询效率。</li>
<li>语句合法性检查(data dict cache)。当在高速缓存中找不到对应的 SQL 语句时则服务器进程就会开始检查这条语句的合法性。这里主要是对 SQL 语句的语法进行检查,看看其是否合乎语法规则。如果服务器进程认为这条 SQL 语句不符合语法规则的时候,就会把这个错误信息,反馈给客户端。注意:此阶段不会对 SQL 语句中所包含的表名、列名等等进行 SQL 他只是语法。</li>
<li>语言含义检查(data dict cache)。若 SQL 语句符合语法上的定义的话,则服务器进程，接下去会对语句中的字段、表等内容进行检查。看看这些字段、表是否在数据库中。</li>
<li>获得对象解析锁(control structer)。当语法、语义都正确后,系统就会对我们需要查询的对象加锁。这主要是为了保障数据的一致性,防止我们在查询的过程中,其他用户对这个对象的结构发生改变。</li>
<li>数据访问权限的核对(data dict cache)。当语法、语义通过检查之后,客户端还不一定能够取得数据。服务器进程还会检查,你所连接的用户是否有这个数据访问的权限。</li>
<li><strong>确定最佳执行计划</strong> 。当语句与语法都没有问题,权限也匹配的话,服务器进程还是不会直接对数据库文件进行查询，服务器进程会根据一定的规则,对这条语句进行优化; 当服务器进程的优化器确定这条查询语句的最佳执行计划后,就会将这条 SQL 语句与执行计划保存到数据高速缓存。</li>
</ol>
</blockquote>
</li>
<li><p><strong>绑定变量</strong></p>
<p>如果SQL语句中使用了绑定变量，扫描绑定变量的声明，给绑定变量赋值，将变量值带入执行计划。若在解析的第一个步骤，SQL在高速缓冲中存在，则直接跳到该步骤。</p>
</li>
<li><p><strong>语句执行</strong></p>
<blockquote>
<p>语句解析只是对 SQL 语句的语法进行解析,以确保服务器能够知道这条语句到底表达的是什么意思。等到语句解析完成之后,数据库服务器进程才会真正的执行这条 SQL 语句。</p>
<p><strong>对于SELECT语句：</strong></p>
<ol>
<li><p>若被选择行所在的数据块已经被读取到数据缓冲区的话,则服务器进程会直接把这个数据传递给客户端,而不是从数据库文件中去查询数据。</p>
</li>
<li><p>若数据不在缓冲区中,则服务器进程将从数据库文件中查询相关数据,并把这些数据放入到数据缓冲区中(buffer cache)</p>
</li>
</ol>
<p><strong>对于DML语句（insert、update、delete）</strong></p>
<ol>
<li>检查所需的数据库是否已经被读取到缓冲区缓存中。如果已经存在缓冲区缓存，则直接执行步骤3；</li>
<li>若所需的数据库并不在缓冲区缓存中，则服务器将数据块从数据文件读取到缓冲区缓存中.</li>
<li>对想要修改的表取得的数据行锁定，之后对所需要修改的数据行取得独占锁；</li>
<li>将数据的Redo记录复制到redo log buffer；</li>
<li>产生数据修改的undo数据；</li>
<li>修改数据，其实是修改的缓存区中的数据（db buffer；）；</li>
<li>后台dbwr将修改写入数据文件；</li>
</ol>
</blockquote>
</li>
<li><p><strong>提取数据</strong></p>
<p>​        当语句执行完成之后,查询到的数据还是在服务器进程中,还没有被传送到客户端的用户进程。所以,在服务器端的进程中,有一个专门负责数据提取的一段代码。他的作用就是把查询到的数据结果返回给用户端进程,从而完成整个查询动作。</p>
<p>最终整体的SQL运行流程如下：</p>
<img src="/Oracle/SQL-Oracle/sqlzxgc.png" alt="SQL执行过程" style="zoom:50%;">

</li>
</ul>
<h2 id="如何写出高性能的SQL"><a href="#如何写出高性能的SQL" class="headerlink" title="如何写出高性能的SQL"></a>如何写出高性能的SQL</h2><p><strong>SQL语句的解析方式</strong></p>
<blockquote>
<p>根据前面我们讲到了高速缓存区，可以知道通过SQL文本计算的哈希值无法在缓存区找到，则开启硬解析的一个过程。优化器最终产生一个最优的执行计划。</p>
<p>总体分析：</p>
<ul>
<li>硬解析即整个<em>SQL</em>语句的执行需要完完全全的解析，生成执行计划。那么此过程就非常消耗CPU和内存资源。</li>
<li>软解析省略了以上过程。</li>
</ul>
<p>SQL语句的解析有软解析soft parse与硬解析hard parse，以下是5个步骤：</p>
<p>1：语法是否合法(sql写法)</p>
<p>2：语义是否合法(权限，对象是否存在)</p>
<p>3：检查该sql是否在共享池中存在</p>
<p>– 如果存在,直接跳过4和5,运行sql. 此时算soft parse</p>
<p>4：选择执行计划</p>
<p>5：产生执行计划</p>
</blockquote>
<p>后续我们重点关注SQL的语句解析和执行计划</p>
<h3 id="减少硬解析"><a href="#减少硬解析" class="headerlink" title="减少硬解析"></a>减少硬解析</h3><p>观察一下SQL的执行的执行过程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span> <span class="keyword">from</span> dual; </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">sysdate</span>  <span class="keyword">from</span> dual;</span><br><span class="line"><span class="keyword">Select</span> <span class="keyword">sysdate</span> <span class="keyword">From</span> Dual;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*对于以上SQL,站在我们开发角度认为他们是相同，但是数据库优化器认为是不同的。</span></span><br><span class="line"><span class="comment">*查询v$sql试图观察实际情况</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">SELECT</span> SQL_TEXT,SQL_ID, FIRST_LOAD_TIME,EXECUTIONS <span class="keyword">FROM</span> V$<span class="keyword">SQL</span>  </span><br><span class="line"><span class="keyword">WHERE</span> SQL_TEXT <span class="keyword">LIKE</span> <span class="string">'% sysdate%'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> FIRST_LOAD_TIME  <span class="keyword">DESC</span> ;</span><br></pre></td></tr></table></figure>

<p>通常我们可以使用一下这些方式排查硬解析</p>
<ul>
<li>排查硬解析的次数 查询某条SQL执行的次数</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span>  SQL_TEXT <span class="keyword">as</span> <span class="keyword">SQL</span>文本,</span><br><span class="line">        EXECUTIONS <span class="keyword">as</span>  执行次数,</span><br><span class="line">        FIRST_LOAD_TIME <span class="keyword">as</span> 初次载入时间,</span><br><span class="line">        PARSE_CALLS <span class="keyword">as</span> 解析调用次数 ,</span><br><span class="line">        DISK_READS <span class="keyword">as</span> 读磁盘次数,</span><br><span class="line">        BUFFER_GETS <span class="keyword">as</span> 读缓存区次数 ,</span><br><span class="line">        OPTIMIZER_MODE <span class="keyword">as</span> <span class="keyword">SQL</span>语句的优化器模型 ,</span><br><span class="line">        CPU_TIME <span class="keyword">as</span> CPU使用时间单位毫秒</span><br><span class="line">         <span class="keyword">from</span> v$<span class="keyword">sql</span> <span class="keyword">where</span> sql_text <span class="keyword">like</span> <span class="string">'%hello sql%'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看SQL只执行过一次的(分析相似的SQL找出硬解析SQL)</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_text <span class="keyword">from</span> v$<span class="keyword">sql</span> <span class="keyword">where</span> EXECUTIONS=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看系统中SQL解析的相关内容（parse count (total)=解析总次数、parse count (hard)=硬解析次数）    </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">name</span>,<span class="keyword">value</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'parse%'</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>查询软解析率。如果软解析率低于30% ，则硬解析过多。 如果总解析量(parse count total)偏低，这项值可以被忽略</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>-(a.value/b.value)/<span class="number">100</span> <span class="keyword">as</span> <span class="string">"软解析率%"</span></span><br><span class="line"><span class="keyword">from</span> v$sysstat a,v$sysstat b</span><br><span class="line"><span class="keyword">Where</span> a.name=<span class="string">'parse count (hard)'</span> <span class="keyword">and</span> b.name=<span class="string">'parse count (total)'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>提高代码的可读性、提高代码安全性、防止SQL注入。</p>
<p><strong>存储过程绑定变量</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- Created on 2020/4/17 by ysshao</span></span><br><span class="line"><span class="keyword">declare</span> </span><br><span class="line"> v_userid <span class="built_in">varchar2</span>(<span class="number">20</span>):=<span class="string">'00010000130'</span>;</span><br><span class="line"> v_name  varchar2(100);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">execute</span> <span class="keyword">immediate</span> <span class="string">'select username from user_info_temp where userid=:1 '</span> <span class="keyword">into</span> v_name  <span class="keyword">using</span> v_userid;</span><br><span class="line"> dbms_output.put_line(v_name);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p><strong>Java程序中绑定</strong></p>
<p>​    参数绑定+批量提交</p>
<h3 id="SQL语句不要太复杂"><a href="#SQL语句不要太复杂" class="headerlink" title="SQL语句不要太复杂"></a>SQL语句不要太复杂</h3><p> 一般将一个Select语句的结果作为子集，然后从该子集中再进行查询，这种一层嵌套语句还是比较常见的，但是根据经验，超过3层嵌套，查询优化器就很容易给出错误的执行计划。因为它被绕晕了，如果人都看晕了，我可以保证数据库也会晕的。</p>
<p>另外执行计划是可以被重用的，越简单的SQL语句被重用的可能性越高。而复杂的SQL语句只要有一个字符发生变化就必须重新解析，然后再把这一大堆垃圾塞在内存里。可想而知，数据库的效率会何等低下。</p>
<p>可以使用with table as语句 ( 目前 oracle、sql server、hive等均支持 with as 用法，但 mysql并不支持！)</p>
<ol>
<li>with table as 可以建立临时表，一次分析，多次使用，同时增加了易读性。</li>
<li>对于复杂查询，使用with table as可以抽取公共查询部分，多次查询时可以提高效率。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--单个语法：</span></span><br><span class="line"><span class="keyword">with</span> tempName <span class="keyword">as</span> (<span class="keyword">select</span> ....)</span><br><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="comment">--多个语法：</span></span><br><span class="line"><span class="keyword">with</span> tempName1 <span class="keyword">as</span> (<span class="keyword">select</span> ....),</span><br><span class="line">tempName2 <span class="keyword">as</span> (<span class="keyword">select</span> ....),</span><br><span class="line">tempName3 <span class="keyword">as</span> (<span class="keyword">select</span> ....) ...</span><br><span class="line"><span class="keyword">select</span> ...  </span><br><span class="line"></span><br><span class="line"><span class="comment">--例如：</span></span><br><span class="line"><span class="keyword">with</span> citab <span class="keyword">as</span> (<span class="keyword">select</span> ei.customerid,ei.enterprisename,ei.corpid <span class="keyword">from</span> customer_info CI,ent_info ei <span class="keyword">where</span> ci.customerid=EI.Customerid ) </span><br><span class="line"><span class="keyword">Select</span> citab.*,BD.*,BC.* <span class="keyword">from</span>  Business_Duebill BD,Business_Contract BC ,citab <span class="keyword">where</span> bd.relativeserialno2=BC.Serialno </span><br><span class="line"><span class="keyword">and</span> citab.customerid=bc.customerid;</span><br></pre></td></tr></table></figure>

<h3 id="使用”临时表”-暂存中间结果"><a href="#使用”临时表”-暂存中间结果" class="headerlink" title="使用”临时表” 暂存中间结果"></a>使用”临时表” 暂存中间结果</h3><p>临时表就是用来暂时保存临时数据（亦或叫中间数据）的一个数据库对象，它和普通表有些类似，然而又有很大区别。它只能存储在临时表空间，而非用户的表空间。ORACLE临时表是会话或事务级别的，只对当前会话或事务可见。每个会话只能查看和修改自己的数据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--会话临时表的语法</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">global</span> <span class="keyword">temporary</span> <span class="keyword">table</span> TMP_TEST</span><br><span class="line"> (</span><br><span class="line">     <span class="keyword">id</span>   <span class="built_in">NUMBER</span>,</span><br><span class="line">      <span class="keyword">name</span> <span class="built_in">VARCHAR2</span>(<span class="number">32</span>)</span><br><span class="line"> )  <span class="keyword">on</span> <span class="keyword">commit</span> <span class="keyword">preserve</span> <span class="keyword">rows</span>;</span><br><span class="line"> 或</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">GLOBAL</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> TMP_TEST <span class="keyword">ON</span> <span class="keyword">COMMIT</span> <span class="keyword">PRESERVE</span> <span class="keyword">ROWS</span> <span class="keyword">AS</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">TEST</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--即只能在会话级别进行生效。关闭会话即数据丢失。</span></span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li><p>当处理某一批临时数据，需要多次DML操作时（插入、更新等），建议使用临时表.最终将修复数据再进行持久化。</p>
</li>
<li><p>当整个会话过程中涉及多出多表关联相同数据时,那么可以将共性数据进行存储。即前期一次存储。后期多次使用。无需再次提取。</p>
<p>注意事项：</p>
</li>
<li><p>不支持 lob 对象，这也许是设计者基于运行效率的考虑。</p>
<ul>
<li>如果要DROP会话级别临时表，并且其中包含数据时，必须先截断(truncate)其中的数据。否则会报错。</li>
</ul>
</li>
</ul>
<h3 id="索引的建立和使用"><a href="#索引的建立和使用" class="headerlink" title="索引的建立和使用"></a>索引的建立和使用</h3><p><strong>索引的用处</strong></p>
<p>索引是数据库对象之一，用于加快数据的检索，类似于书籍的索引。在数据库中索引可以减少数据库程序查询结果时需要读取的数据量，类似于在书籍中我们利用索引可以不用翻阅整本书即可找到想要的信息。</p>
<p><strong>索引分类</strong></p>
<ul>
<li><p>B树索引</p>
<p>默认索引，保存排序过的索引列和对应的rowid值</p>
<p>列基数（列不重复值的个数）时适合使用B数索引</p>
<p>语法：create index indexName on tableName(column1);</p>
</li>
<li><p>位图索引</p>
<p>创建位图索引时，oracle会扫描整张表，并为索引列的每个取值建立一个位图</p>
<p>对于基数小的列适合位图索引（例如性别、职业等）</p>
<p>语法：create bitmap index index_sex on student(sex);</p>
</li>
<li><p>联合索引</p>
<p>建立联合索引的语法：</p>
<p>create index indexName on tableName(column1,column2,…,columnN)，</p>
<p> 联合索引可以建立多列(列数大于2)的索引,建议列数最多不要越过3列. </p>
</li>
</ul>
<p><strong>索引建立原则总结</strong></p>
<blockquote>
<ul>
<li><p>如果有两个或者以上的索引，其中有一个唯一性索引，而其他是非唯一，这种情况下oracle将使用唯一性索引而完全忽略非唯一性索引</p>
</li>
<li><p>索引应该建立在频繁使用的表列上，并且检索的行数低于总行数的15%。可以考虑建立索引。</p>
</li>
<li><p>限制表的索引个数、索引主要用于加快查询速度，但会降低DML操作。索引越多，DML操作越慢，因此索引规划时需要权衡查询和DML需求。</p>
</li>
<li><p>小表不要建立索引.</p>
</li>
<li><p>对于基数大的列适合建立B树索引，对于基数小的列适合建立位图索引</p>
</li>
<li><p>列中有很多空值，但经常查询该列上非空记录时应该建立索引</p>
</li>
<li><p>经常进行连接查询的列应该创建索引</p>
</li>
<li><p>创建联合索引时要将最常查询的列放在最前面</p>
</li>
<li><p>海量数据表有频繁的更新，这时可以先删除索引，插入数据，再重新建立索引来达到高效的目的。</p>
</li>
</ul>
</blockquote>
<p><strong>索引失效的情况</strong></p>
<blockquote>
<p>Oracle建立索引的目的是为了避免全表扫描，提高查询的效率。</p>
<p>但是有些情况下，即使建立了索引，但是执行写出来的查询还是很慢，然后通过执行计划会发现是索引失效导致的（不走索引，走全表扫描）。所以需要了解一下有哪些情况会导致索引失效。</p>
<p>即查询不走索引的原因：</p>
<ol>
<li><p>使用判断空或非空的条件会导致该索引列失效；</p>
</li>
<li><p>复合索引未用左列字段;</p>
</li>
<li><p>like以%开头;</p>
</li>
<li><p>需要类型转换;</p>
</li>
<li><p>where中索引列有运算;</p>
</li>
<li><p>where中索引列使用了函数;</p>
</li>
<li><p>not in ,not exist.</p>
</li>
<li><p>表没分析.索引失效。</p>
<p>…..</p>
</li>
</ol>
</blockquote>
<h3 id="读懂执行计划"><a href="#读懂执行计划" class="headerlink" title="读懂执行计划"></a>读懂执行计划</h3><p><strong>优化器和成本</strong></p>
<p>在介绍执行计划之前，首先要介绍的就是优化器和成本，优化器是数据库最核心，也是最复杂的一个模块。</p>
<p>选择最优的执行计划。优化器选取，算法决定了执行计划的好坏。</p>
<p>Oracle中优化器是SQL分析和执行的优化工具，它负责生成、制定SQL的执行计划</p>
<p>优化器要是以下两种:</p>
<blockquote>
<p><strong>RBO（Rule-Based Optimization） 基于规则的优化器**</strong></p>
<ul>
<li><p>RBO有严格的使用规则，只要按照这套规则去写SQL语句，无论数据表中的内容怎样，也不会影响到</p>
<p>你的执行计划； </p>
</li>
<li><p>RBO一直沿用至ORACLE 9i，从ORACLE 10g开始，RBO已经彻底被抛弃。</p>
</li>
</ul>
<p><strong>CBO（Cost-Based Optimization） 基于代价的优化器</strong></p>
<ul>
<li><p>CBO是一种比RBO更加合理、可靠的优化器，在ORACLE 10g中完全取代RBO；</p>
</li>
<li><p>CBO通过计算各种可能的执行计划的“代价”，即COST，从中选用COST最低的执行方案作为实际运行方案；</p>
</li>
</ul>
<p>它依赖数据库对象的统计信息，统计信息的准确与否会影响CBO做出最优的选择，也就是对数据“敏感”。</p>
<p>这个就涉及到Oracle收集统计信息。比如Oracle 11g1默认启动了统计信息收集的任务</p>
<p>自动收集的条件：</p>
<ul>
<li>对象的统计信息之前没有收集过。</li>
<li>当对象有超过10%的rows 被修改，此时对象的统计信息也称为stale statistics。</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查看自动收集任务及状态：</span></span><br><span class="line"><span class="keyword">select</span> client_name,<span class="keyword">status</span> <span class="keyword">from</span> Dba_Autotask_Client <span class="keyword">where</span> client_name=<span class="string">'auto optimizer stats collection'</span>;</span><br><span class="line"><span class="comment">--查看自动收集任务执行时间窗口</span></span><br><span class="line"><span class="keyword">select</span> WINDOW_NAME, WINDOW_NEXT_TIME , WINDOW_ACTIVE,OPTIMIZER_STATS <span class="keyword">from</span> DBA_AUTOTASK_WINDOW_CLIENTS <span class="keyword">order</span> <span class="keyword">by</span> WINDOW_NEXT_TIME ;</span><br></pre></td></tr></table></figure>

<p>手动收集统计信息</p>
<p>一般统计信息用于晚间批量涉及大量数据的变化（插入、更新、删除）。建议手动执行统计信息。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">--收集表的统计信息</span></span><br><span class="line"><span class="comment">--分析表的所有字段，所有索引，所有索引字段。</span></span><br><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> tabname <span class="keyword">compute</span> <span class="keyword">statistics</span>;  </span><br><span class="line"><span class="comment">--分析表的所有字段，所有索引，所有索引字段。效果同上</span></span><br><span class="line"><span class="keyword">analyze</span> <span class="keyword">table</span> tabname <span class="keyword">compute</span> <span class="keyword">statistics</span> <span class="keyword">for</span> <span class="keyword">table</span> <span class="keyword">for</span> <span class="keyword">all</span> <span class="keyword">indexes</span> <span class="keyword">for</span> <span class="keyword">all</span> <span class="keyword">columns</span>;   </span><br><span class="line"><span class="comment">--查询表的统计信息</span></span><br><span class="line"><span class="keyword">select</span> table_name,num_rows,blocks,last_analyzed <span class="keyword">from</span> user_tables <span class="keyword">where</span> table_name=<span class="string">'AUDIT_INFO'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-----也可以通过BMS_STATS等包批量分析某个用户或者整个数据库。</span></span><br><span class="line"><span class="comment">--按照用户收集统计信息</span></span><br><span class="line">exec dbms_stats.gather_schema_stats(ownname=&gt;'XXX', options=&gt; 'GATHER AUTO',estimate_percent=&gt; dbms_stats.auto_sample_size,degree=&gt;8,cascade=&gt;true,granularity=&gt;'ALL');  </span><br><span class="line"><span class="comment">--按照表收集统计信息</span></span><br><span class="line">exec  dbms_stats.gather_table_stats(ownname=&gt;'XXX',tabname=&gt;'XXX_TAB',degree=&gt;8,cascade=&gt;true,granularity=&gt;'ALL');</span><br></pre></td></tr></table></figure>

<p>可以根据需要统计的信息 使用存储过程调用或者是编写脚本放入linux定时任务。 每天几点执行。</p>
<p><strong>优化器相关的Hint</strong></p>
<p>在整个SQL优化中，除了按系统默认的优化器来执行，还可以使用提示的方式来干预，能够辅助优化器进行更精准的执行。</p>
<p>主要的Hint包括：</p>
<blockquote>
<ul>
<li><p>ALL_ROWS：它的含义是优化器启用CBO，也就是按照资源消耗量（CPU、I/O等方面）最小来计算执行。</p>
</li>
<li><p>FIRST_ROWS(n) ：它的含义是优化器启用CBO,而且在得到目标SQL的执行计划时会选择那些能够以最快速度响应并返回的前N条记录的执行路径。</p>
<p>注意：如果在Update、delete中使用此hint则会被Oracle忽略。</p>
</li>
<li><p>RULE: 它表示对目标SQL启用RBO，不推荐使用。</p>
</li>
</ul>
</blockquote>
<p><strong>成本</strong></p>
<p>在SQL优化过程中，成本非常重要，Oracle绝大多数都是使用基于成本的优化器来制定执行计划。</p>
<p>成本(COST)计算公式：</p>
<img src="/Oracle/SQL-Oracle/sqlcb.png" style="zoom:50%;">



<p><strong>什么是执行计划？</strong></p>
<p>执行计划是SQL优化的基础，数据库执行的SQL是按照一定的顺序、步骤执行的，至于采用什么方式访问数据由优化器决定。一旦优化器决定好一个它认为最高效的方式，后续一系列的方式顺序、步骤就是执行计划。</p>
<p><strong>执行计划的获取</strong></p>
<p>方式一：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> plan <span class="keyword">for</span>  <span class="keyword">select</span> XXX <span class="keyword">from</span> XXX;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display()); </span><br><span class="line"><span class="comment">--注意只能执行DML语句，不能执行DDL。查看完毕后需要提交或回滚事务</span></span><br><span class="line"><span class="comment">--使用PLSQL Developer连接工具中的F5</span></span><br></pre></td></tr></table></figure>

<p>方式二：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--跟踪信息记录，最常用的方式，在命令行窗口执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示执行结果、执行计划、统计信息</span></span><br><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">on</span> <span class="keyword">exp</span> <span class="keyword">statistics</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> xxx;</span><br><span class="line"><span class="comment">--显示执行计划、统计信息</span></span><br><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">trace</span> <span class="keyword">exp</span> <span class="keyword">statistics</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> xxx;</span><br><span class="line"><span class="comment">--只显示执行计划</span></span><br><span class="line"><span class="keyword">set</span> autotrace <span class="keyword">trace</span> <span class="keyword">exp</span> ;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table_name <span class="keyword">where</span> xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">--补充在执行SQL执行，可显示SQL执行时间</span></span><br><span class="line"><span class="keyword">set</span> timing <span class="keyword">on</span>;</span><br></pre></td></tr></table></figure>

<p><strong>执行计划的简单解读</strong></p>
<ul>
<li><p><strong>执行计划查看顺序</strong></p>
<p>执行计划的查看规则：（从上往下，从右往左）</p>
<p>先从开头一直连续往右看，直到看到右边并列的地方；对于不并列的，靠右的先执行；如果看到并列，从上往下看，对于并列的部分，靠上的先执行。</p>
<p><code>遵循最上最右先执行的原则</code></p>
</li>
<li><p><strong>执行计划字段的解释</strong></p>
<blockquote>
<p><strong>ID</strong>: 一个序号，但不是执行的先后顺序。执行的先后根据缩进来判断。</p>
<p><strong>Operation</strong>： 当前操作的内容。</p>
<p><strong>Rows</strong>： 当前操作的Cardinality，Oracle估计当前操作的返回结果集。</p>
<p><strong>Cost（CPU）：</strong>Oracle 计算出来的一个数值（代价），用于说明SQL执行的代价。</p>
<p><strong>Time</strong>：Oracle 估计当前操作的时间。</p>
</blockquote>
</li>
<li><p><strong>访问路径</strong></p>
<p>访问路径这个步骤是确定以什么方式访问数据库的。</p>
<blockquote>
<p>常见的分类：</p>
<ul>
<li><p>表相关的访问路径：</p>
<p>TABLE ACCESS BY …  即描述的是该动作执行时表访问</p>
<ul>
<li><p>TABLE ACCESS FULL（全表扫描）</p>
<p>Oracle会读取表中所有的行，并检查每一行是否满足SQL语句中的 Where 限制条件；全表扫描时可以使用多块读（即一次I/O读取多块数据块）操作，提升吞吐量；<br>使用建议：数据量太大的表不建议使用全表扫描，除非本身需要取出的数据较多，占到表数据总量的 5% ~ 10% 或以上</p>
</li>
<li><p>TABLE ACCESS BY ROWID（通过ROWID的表存取）</p>
<p>Oracle中存取单行数据最快的方法.</p>
</li>
<li><p>TABLE ACCESS BY INDEX SCAN（索引扫描）</p>
<p>在索引块中，既存储每个索引的键值，也存储具有该键值的行的ROWID。</p>
<p>所以索引扫描其实分为两步：<br>1.扫描索引得到对应的ROWID<br>2.通过ROWID定位到具体的行读取数据</p>
</li>
</ul>
</li>
<li><p>索引相关的访问路径</p>
<p>INDEX….即索引的访问路径</p>
<p>索引扫描又分五种：</p>
<ul>
<li><p>INDEX UNIQUE SCAN（索引唯一扫描）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">针对唯一性索引（UNIQUE INDEX）的扫描，每次至多只返回一条记录； </span><br><span class="line">表中某字段存在 UNIQUE、PRIMARY KEY 约束时</span><br></pre></td></tr></table></figure>
</li>
<li><p>INDEX RANGE SCAN（索引范围扫描）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">使用一个索引存取多行数据；</span><br><span class="line">发生索引范围扫描的三种情况：</span><br><span class="line">a、在唯一索引列上使用了范围操作符（如：&gt;   &lt;   &lt;&gt;   &gt;=   &lt;=  	        between）</span><br><span class="line">b、在组合索引上，只使用部分列进行查询（查询时必须包含前导列，否则会走全表    扫描）</span><br><span class="line">c、对非唯一索引列上进行的任何查询。</span><br></pre></td></tr></table></figure>
</li>
<li><p>INDEX FULL SCAN（索引全扫描）</p>
<p>​    进行全索引扫描时，查询出的数据都必须从索引中可以直接得到（注意全索引扫描只有在CBO模式下才有效）</p>
</li>
<li><p>INDEX FAST FULL SCAN（索引快速扫描）</p>
<p>扫描索引中的所有的数据块，与 INDEX FULL SCAN 类似，但是一个显著的区别是它不对查询出的数据进行排序（即数据不是以排序顺序被返回）</p>
</li>
<li><p>INDEX SKIP SCAN（索引跳跃扫描）</p>
<p>前提条件：表有一个复合索引，且在查询时有除了前导列（索引中第一列）外的其他列作为条件，并且优化器模式为CBO时.</p>
<p>当Oracle发现前导列的唯一值个数很少时，会将每个唯一值都作为常规扫描的入口，在此基础上做一次查找，最后合并这些查询；</p>
</li>
</ul>
</li>
<li><p>表关联关系的访问路径</p>
<p>NESTED LOOPS … 描述的是表连接方式</p>
<ul>
<li><p>SORT MERGE JOIN（排序-合并连接）</p>
<p>​    适用的连接方式：&lt;  &lt;= &gt; &gt;= 等。分别会对各表排序，然后合并汇总。</p>
<p>​    首先对两个表按照关联的字段进行排序，分别从两个表中取出一行数据进行匹配，如果合适放入结果集；不匹配将较小的那行丢掉继续匹配另一个表的下一行，依次处理直到将两表的数据取完。merge join的很大一部分开销花在排序上，也是同等条件下差于hash join的一个主要原因。</p>
</li>
<li><p>NESTED LOOPS（嵌套循环）</p>
<p>嵌套循环是比较通用的连接方式，每扫描外表的一行数据都要在内表中查找与之相匹配的行。一般来讲会通过索引来提升性能。</p>
<p><strong>嵌套循环的表有驱动顺序，注意选择合适的驱动表。From最后一张表为驱动表</strong></p>
<p>嵌套循环连接有一个其他连接方式没有的好处是：<strong>可以先返回已经连接的行</strong>，而不必等所有的连接操作处理完才返回数据，这样可以实现快速响应。</p>
<p>通常情况下，优化器在选择执行计划时，不会考虑表在FROM语句中出现的顺序。优化器依次根据下面的规则来作出选择</p>
<p>优化器选择执行计划使得内部表为全表扫描的NESTED LOOPS连接尽可能的少；</p>
<p>如果采用上面的条件出现了平局的情况，则优化器选择尽可能少出现SORT MERGE操作的执行计划；</p>
<p>如果仍然出现平局的情况，则优化器将选择表访问路径中排名最高的表作为驱动表；</p>
<p>如果这时仍然是平局，则优化器会把FROM语句中最后出现的表最为驱动表。</p>
</li>
<li><p>HASH JOIN（哈希连接）</p>
<p>hash-join就算讲两表中的小表（称S）作为hash表，然后去扫描另一个表(称M)的每一行数据，用得出来的行数据根据连接条件去映射建立的hash表，hash表是放在内存中的，这样可以很快的得到对应的S表与M表相匹配的行。</p>
</li>
<li><p>CARTESIAN PRODUCT（笛卡尔积）</p>
<p>通常由编写代码疏漏造成。</p>
</li>
</ul>
<p>注：　　</p>
<ul>
<li>对于结果集很大的情况，merge-join需要对其排序效率并不会很高，而nested loop join是一种嵌套循环的查询方式无疑更不适合大数据集的连接，而hash-join正是为处理这种棘手的查询方式而生，尤其是对于一个大表和一个小表的情况，基本上只需要将大小表扫描一遍就可以得出最终的结果集。</li>
</ul>
</li>
<li><p>不过hash-join只适用于等值连接，对于&gt;, &lt;, &lt;=, &gt;=这样的查询连接还是需要nested loop这种通用的连接算法来处理。如果连接key本来就是有序的或者需要排序，那么可能用merge-join的代价会比hash-join更小，此时merge-join会更有优势。</p>
<ul>
<li>Oracle一次只能连接两个表。不管查询中有多少个表，Oracle在连接中一次仅能操作两张表</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>统计信息</strong></p>
<table>
<thead>
<tr>
<th>Statistics</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>recursive calls</td>
<td>产生的递归sql调用的条数。</td>
</tr>
<tr>
<td>Db block gets:</td>
<td>从buffer cache中读取的block的数量</td>
</tr>
<tr>
<td>consistent gets</td>
<td>从buffer cache中读取的undo数据的block的数量</td>
</tr>
<tr>
<td>physical reads</td>
<td>从磁盘读取的block的数量</td>
</tr>
<tr>
<td>redo size</td>
<td>DML生成的redo的大小</td>
</tr>
<tr>
<td>bytes sent via SQL*Net to client</td>
<td>数据库服务器通过SQL*Net向查询客户端发送的查询结果字节数</td>
</tr>
<tr>
<td>bytes received via SQL*Net from client</td>
<td>通过SQL*Net接受的来自客户端的数据字节数</td>
</tr>
<tr>
<td>SQL*Net roundtrips to/from client</td>
<td>服务器和客户端来回往返通信的Oracle Net messages条数</td>
</tr>
<tr>
<td>sorts (memory)</td>
<td>在内存执行的排序量</td>
</tr>
<tr>
<td>sorts (disk)</td>
<td>在磁盘上执行的排序量</td>
</tr>
<tr>
<td>rows processed</td>
<td>处理的数据的行数</td>
</tr>
</tbody></table>
</li>
</ul>
<p>使用执行计划进行SQL调优</p>
<ol>
<li><p>查看总COST，获得资源耗费的总体印象 </p>
<p>一般而言，执行计划第一行所对应的COST(即成本耗费)值，反应了运行这段SQL的总体估计成本，单看这个总成本没有实际意义，但可以拿它与相同逻辑不同执行计划的SQL的总体COST进行比较，通常COST低的执行计划要好一些。</p>
</li>
<li><p>按照从左至右，从上至下的方法，了解执行计划的执行步骤 </p>
</li>
<li><p>分析表的访问方式 </p>
</li>
<li><p>分析表的连接方式和连接顺序 </p>
</li>
</ol>
<h3 id="加快SQL的执行速度"><a href="#加快SQL的执行速度" class="headerlink" title="加快SQL的执行速度"></a>加快SQL的执行速度</h3><p><strong>Oracle Hint</strong></p>
<p>基于代价的优化器是很聪明的，在绝大多数情况下它会选择正确的优化器,但有时候也会选择较差的执行计划，使某个语句的执行变得奇慢无比。此时就需要人为干预。告诉优化器应该怎样执行。</p>
<p>当遇到SQL执行计划不好的情况，应优先考虑统计信息等问题，而不是直接加Hint了事。如果统计信息无误，应该考虑物理结构是否合理，即没有合适的索引。只有在最后仍然不能SQL按优化的执行计划执行时，才考虑Hint。</p>
<p>用法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span>|<span class="keyword">SELECT</span>|<span class="keyword">UPDATE</span>|<span class="keyword">DELETE</span> <span class="comment">/*+ hint  */</span>  ....</span><br><span class="line"><span class="comment">--"+"号表示该注释是一个提示，该加号必须立即跟在"/*"的后面，中间不能有空格。</span></span><br><span class="line"><span class="comment">--hint是下面介绍的具体提示之一，如果包含多个提示，则每个提示之间需要用一个或多个空格隔开。</span></span><br></pre></td></tr></table></figure>

<p>常用Hint:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*+ parallel(table_name n) */</span></span><br><span class="line"></span><br><span class="line">在sql中指定执行的并行度，这个值将会覆盖自身的并行度和优化器相关的hint</span><br><span class="line"><span class="comment">/*+ ALL_ROWS */</span> 表明对语句块选择基于开销的优化方法,并获得最佳吞吐量,使资源消耗最小化.</span><br><span class="line"><span class="comment">/*+ FIRST_ROWS(n) */</span> 表明对语句块选择基于开销的优化方法,并获得最佳响应时间,使资源消耗最小化.</span><br><span class="line"><span class="comment">/*+ RULE*/</span> 表明对语句块选择基于规则的优化方法.</span><br><span class="line"> 和访问路径相关的hint </span><br><span class="line"><span class="comment">/*+ FULL(TABLE)*/</span> 表明对表选择全局扫描的方法.</span><br><span class="line"><span class="comment">/*+ INDEX(TABLE INDEX_NAME) */</span> 表明对表选择索引的扫描方法.</span><br><span class="line"><span class="comment">/*+ INDEX_ASC(TABLE INDEX_NAME)*/</span> 表明对表选择索引升序的扫描方法.</span><br><span class="line">....</span><br><span class="line">和表相关的所有hint</span><br><span class="line"><span class="comment">/*+ leading(TABLE) */</span>  指定哪个表为驱动表</span><br><span class="line"><span class="comment">/*+ ordered */</span>    指定按照from后面的顺序来选择谁做驱动表</span><br><span class="line"><span class="comment">/*+ use_hash(t,t1) */</span>   表明采用hash方式连接</span><br><span class="line"><span class="comment">/*+ use_nl(t,t1) */</span>   表明采用nested loop方式连接</span><br><span class="line"><span class="comment">/*+ use_merge(t,t1) */</span>  表明采用<span class="keyword">merge</span>方式连接</span><br><span class="line">其他hint</span><br><span class="line"><span class="comment">/*+ parallel(table_name n) */</span> 在<span class="keyword">sql</span>中指定执行的并行度，这个值将会覆盖自身的并行度</span><br><span class="line"><span class="comment">/*+ append */</span>以直接加载的方式将数据加载入库</span><br><span class="line"></span><br><span class="line"><span class="comment">---案例</span></span><br><span class="line"><span class="comment">--使用FIRST_ROWS(n)临时解决查询特别慢的SQL</span></span><br><span class="line"><span class="keyword">select</span><span class="comment">/*+ FIRST_ROWS(5) */</span> * <span class="keyword">from</span> table_xx ;</span><br><span class="line"><span class="comment">--强制走索引</span></span><br><span class="line"><span class="keyword">Select</span>   <span class="comment">/*+ index(tt  IDX_tt_Serialno) */</span>   * <span class="keyword">from</span>  tablename tt <span class="keyword">order</span> <span class="keyword">by</span> serialno;</span><br><span class="line"><span class="comment">--并行</span></span><br><span class="line"><span class="keyword">insert</span> <span class="comment">/*+ parallel(tt 4) */</span> <span class="keyword">into</span> audit_info_temp2 tt  <span class="keyword">Select</span> * <span class="keyword">from</span> audit_info;</span><br><span class="line"><span class="comment">/*+parallel(t,10) (b,10)*/</span> <span class="comment">--多表并行</span></span><br></pre></td></tr></table></figure>

<p><strong>oracle减少redo size的方法：</strong></p>
<blockquote>
<p>oralce日志模式默认情况是logging，就是会记录到redo日志中，force logging是强制记录日志，nologging是尽量减少日志。FORCE LOGGING可以在数据库级别、表空间级别进行设定、而LOGGING与NOLOGGING可以在表级别设定。<br>ORACLE数据库会对产生改变的操作DML记录REDO，比如DDL语句、DML语句，这些操作首先会放在redo buffer中，然后由LGER进程根据触发条件写到联机日志文件，如果数据库开启归档的话，还要在日志切换的时候归档。<br>对于我们来说，最好的调优方式就是不产生REDO或者尽量少的产生REDO。<br>设置NOLOGGING模式<br>此模式不是不记录日志，而是最小化日志产生的数量，通常在下列情况下使用NOLOGGING</p>
<p>/<em>+APPEND</em>/的作用是在表的高水位上分配空间,不再使用表的extent中的空余空间<br>append 属于direct insert, 不去寻找 freelist 中的free block , 直接在table HWM 上面加入数据。</p>
<p>注：归档日志就少了，可能不能用于介质恢复了</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--nologging模式通常和append联合使用。</span></span><br><span class="line">非归档模式下：</span><br><span class="line"><span class="keyword">insert</span> <span class="comment">/*+ append nologging */</span> <span class="keyword">into</span> audit_info_temp1 <span class="keyword">Select</span> * <span class="keyword">from</span> audit_info;</span><br><span class="line">归档模式下：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> XXX nologging; </span><br><span class="line"><span class="keyword">insert</span> <span class="comment">/*+ append nologging */</span> <span class="keyword">into</span> table1 <span class="keyword">select</span> * <span class="keyword">from</span> table2;</span><br><span class="line"><span class="comment">--查询redo日志产生的大小</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">value</span>,<span class="keyword">class</span> <span class="keyword">from</span> v$sysstat <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'redo size'</span>;</span><br></pre></td></tr></table></figure>

<p>Oracle并行</p>
<blockquote>
<p>并行处理的机制实际上就是把一个要扫描的数据集分成很多小数据集，Oracle会启动几个并行服务进程同时处理这些小数据集，最后将这些结果汇总，作为最终的处理结果返回给用户。<br>使用并行方式，不论是创建表，修改表，创建索引，重建索引，他们的机制都是一样的，那就是Oracle 给每个并行服务进程分配一块空间，每个进程在自己的空间里处理数据，最后将处理完毕的数据汇总，完成SQL的操作。</p>
</blockquote>
<p><strong>并行查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询当前会话是否开启并行查询  并行查询是默认开启的;</span></span><br><span class="line"><span class="keyword">Select</span> PQ_STATUS <span class="keyword">from</span> v$<span class="keyword">session</span> <span class="keyword">where</span> <span class="keyword">sid</span>=sys_context(<span class="string">'userenv'</span>,<span class="string">'sid'</span>);</span><br><span class="line"><span class="comment">--开启并行查询</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">session</span> <span class="keyword">enable</span> <span class="keyword">parallel</span> <span class="keyword">query</span>;</span><br><span class="line"><span class="comment">--设置表级的并行数量  一般不建议此方式</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">table</span> tab1 <span class="keyword">parallel</span> n;<span class="comment">-- 默认为1  不指定为DEFAULT</span></span><br><span class="line"><span class="comment">--Hint方式  建议使用</span></span><br><span class="line"><span class="keyword">Select</span> <span class="comment">/*+parallel(tab n)*/</span> <span class="keyword">from</span> tab;</span><br><span class="line"><span class="keyword">Select</span> <span class="comment">/*+parallel(tab,n)*/</span> <span class="keyword">from</span> tab;</span><br></pre></td></tr></table></figure>

<p><strong>并行DML</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--查询当前会话是否开启并行DML 并行DML默认是关闭 </span></span><br><span class="line"><span class="keyword">Select</span> PDML_STATUS <span class="keyword">from</span> v$<span class="keyword">session</span> <span class="keyword">where</span> <span class="keyword">sid</span>=sys_context(<span class="string">'userenv'</span>,<span class="string">'sid'</span>);</span><br><span class="line"><span class="comment">--开启和关闭会话并行DML</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">enable</span> <span class="keyword">parallel</span> dml;<span class="comment">--开启</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">session</span> <span class="keyword">disable</span> <span class="keyword">parallel</span> dml;<span class="comment">--关闭</span></span><br><span class="line"><span class="comment">--表级并行  不建议</span></span><br><span class="line"><span class="keyword">Alter</span> <span class="keyword">table</span> tab <span class="keyword">parallel</span> n;<span class="comment">-- 默认为1  不指定为DEFAULT</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> taba <span class="keyword">Select</span> * <span class="keyword">from</span> tabb;</span><br><span class="line"><span class="comment">--HINT方式  建议</span></span><br><span class="line"><span class="keyword">update</span> <span class="comment">/*+parallel(aa 6) */</span> tabname aa  <span class="keyword">set</span> <span class="keyword">column</span>=XXX;</span><br></pre></td></tr></table></figure>

<p>并行DML使用注意事项：</p>
<blockquote>
<ol>
<li><p>不支持触发器。</p>
</li>
<li><p>在提交和回滚之前。 不能对该表进行DML操作。 </p>
<p>目前已论证：</p>
<p>update 并行只进行行级排它锁。可以非行级锁的操作。如insert</p>
<p>insert  并行会对占用表级排它锁。 无法进行任何DML操作</p>
</li>
<li><p>并行查询是默认开启的。 并行DML默认不开启。</p>
</li>
<li><p>9i之前并行要求必须分区。 9i之后解除了限制。</p>
</li>
</ol>
</blockquote>
<p><strong>并行相关视图查询</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">---查看表相关信息</span></span><br><span class="line"><span class="keyword">Select</span>  table_name,tablespace_name,<span class="keyword">logging</span>,num_rows,degree,partitioned ,user_stats ,last_analyzed <span class="keyword">from</span> user_tables;</span><br><span class="line"><span class="comment">--查看并行执行的会话</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>  t.sql_text,t.sql_id,s.sid <span class="keyword">from</span> v$<span class="keyword">sql</span> t,v$<span class="keyword">session</span> s <span class="keyword">where</span> t.sql_id=s.sql_id <span class="keyword">and</span> t.sql_text <span class="keyword">like</span> <span class="string">'%张三%'</span>;</span><br><span class="line"><span class="comment">--查询进程池中的并行进程数 </span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> v$px_process;</span><br></pre></td></tr></table></figure>

<p>注意:</p>
<ul>
<li><p>默认并行度<br>单实例 = PARALLEL_THREADS_PER_CPU x CPU_COUNT<br>RAC = PARALLEL_THREADS_PER_CPU x CPU_COUNT x INSTANCE_COUNT</p>
</li>
<li><p>并行的并行度的优先级从高到低为：</p>
<p><strong>Hint-&gt;alter session force parallel-&gt;表，索引上的设定-&gt; 系统参数</strong></p>
</li>
<li><p>Hint是比较”暴力”的一种解决方式，不是很优雅。需要开发人员手工修改代码。</p>
</li>
<li><p>Hint不会去适应新的变化。比如数据结构、数据规模发生了重大变化，但使用Hint的语句是感知变化并产生更优的执行计划。</p>
</li>
<li><p>Hint随着数据库版本的变化，可能会有一些差异、甚至废弃的情况。此时，语句本身是无感知的，必须人工测试并修正。</p>
</li>
</ul>
<h2 id="SQL优化法则"><a href="#SQL优化法则" class="headerlink" title="SQL优化法则"></a>SQL优化法则</h2><p>常见的优化法则。这里所说的优化法则，其实是指可以从那些角度去考虑SQL优化的问题。可以有很多种方式去看待它。</p>
<img src="/Oracle/SQL-Oracle/sqlyh.png" alt="漏斗法则" style="zoom:80%;">

<p>​    这个优化法则归纳为5个层次：</p>
<ol>
<li><p>减少数据访问（减少磁盘访问）</p>
</li>
<li><p>返回更少数据（减少网络传输或磁盘访问）</p>
</li>
<li><p>减少交互次数（减少网络传输）</p>
</li>
<li><p>减少服务器CPU开销（减少CPU及内存开销）</p>
</li>
<li><p>利用更多资源（增加资源）</p>
<p><strong>自低向上</strong></p>
</li>
</ol>
<img src="/Oracle/SQL-Oracle/oracle_yh.png" alt="自低向上" style="zoom:60%;">

<p>关于SQL、Oracle优化需要探索的内容和方式还有很多，本文只是站在程序员开发角度的思路来整理。</p>
<p>希望能够帮助到各位朋友~</p>
<hr>
<p>本文章部分内容参考文献：《SQL优化最佳实践》</p>
<p>本文参考的文章:</p>
<p>​    <a href="https://www.cnblogs.com/zzl-156783663/p/8506488.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzl-156783663/p/8506488.html</a></p>
<p>​    <a href="http://blog.itpub.net/69918724/viewspace-2651106/" target="_blank" rel="noopener">http://blog.itpub.net/69918724/viewspace-2651106/</a></p>
]]></content>
      <categories>
        <category>Oracle</category>
      </categories>
      <tags>
        <tag>Oracle</tag>
        <tag>SQL优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IOC 容器源码分析</title>
    <url>/open-source/Spring_SourceCode/</url>
    <content><![CDATA[<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。</p>
<p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p>
<p>阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p>
<p>希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先看下最基本的启动 Spring 容器的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationfile.xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p>
</blockquote>
<p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。</p>
<p>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p>
<p><img src="https://www.javadoop.com/blogimages/spring-context/1.png" alt="1"></p>
<blockquote>
<p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。</p>
<p>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p>
</blockquote>
<p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 <strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类。</p>
<p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p>
<p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p>
<p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p>
<p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p>
<p>首先，定义一个接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义接口实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，我们就可以跑起来了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:application.xml"</span>);</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"context 启动成功"</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line">        MessageService messageService = context.getBean(MessageService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p>
<h2 id="BeanFactory-简介"><a href="#BeanFactory-简介" class="headerlink" title="BeanFactory 简介"></a>BeanFactory 简介</h2><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p>
<p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p>
<p><img src="https://www.javadoop.com/blogimages/spring-context/2.png" alt="2"></p>
<p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p>
<ol>
<li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li>
<li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li>
<li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li>
<li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li>
<li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li>
</ol>
<p>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p>
<h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p>
<p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p>
<p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们开始一步步来肢解这个 refresh() 方法。</p>
<h3 id="创建-Bean-容器前的准备工作"><a href="#创建-Bean-容器前的准备工作" class="headerlink" title="创建 Bean 容器前的准备工作"></a>创建 Bean 容器前的准备工作</h3><p>这个比较简单，直接看代码中的几个注释即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h3><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p>
<p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p>
<p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p>
<p>// AbstractApplicationContext.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>// AbstractRefreshableApplicationContext.java 120</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span></span><br><span class="line">   <span class="comment">// ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 下面这两个方法很重要，别跟丢了，具体细节之后说</span></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p>
</blockquote>
<p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p>
<p><img src="https://www.javadoop.com/blogimages/spring-context/3.png" alt="3"></p>
<p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p>
<blockquote>
<p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p>
<p>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p>
<p>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p>
</blockquote>
<p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p>
<p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p>
<p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p>
<blockquote>
<p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p>
</blockquote>
<h4 id="BeanDefinition-接口定义"><a href="#BeanDefinition-接口定义" class="headerlink" title="BeanDefinition 接口定义"></a>BeanDefinition 接口定义</h4><p>我们来看下 BeanDefinition 的接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(String parentName)</span></span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on="" 属性设置的值。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span></span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span></span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   <span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p>
<p>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p>
</blockquote>
<p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br></pre></td></tr></table></figure>

<p>虽然只有两个方法，但路还很长啊。。。</p>
<h4 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h4><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 定义覆盖</span></span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 间的循环依赖</span></span><br><span class="line">      beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p>
<p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p>
<p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p>
<p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p>
<h4 id="加载-Bean-loadBeanDefinitions"><a href="#加载-Bean-loadBeanDefinitions" class="headerlink" title="加载 Bean: loadBeanDefinitions"></a>加载 Bean: loadBeanDefinitions</h4><p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p>
<p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p>
<p>// AbstractXmlApplicationContext.java 80</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class="line">   <span class="comment">// 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 重点来了，继续往下</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p>
<p>// AbstractXmlApplicationContext.java 120</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 往下看</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">   <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 注意这里是个 for 循环，也就是每个文件是一个 resource</span></span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      <span class="comment">// 继续往下看</span></span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最后返回 counter，表示总共加载了多少的 BeanDefinition</span></span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 303</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 314</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用一个 ThreadLocal 来存放配置文件资源</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 核心部分是这里，往下面看</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还在这个文件中，第 388 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里就不看了，将 xml 文件转换为 Document 对象</span></span><br><span class="line">      Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 继续</span></span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还在这个文件中，第 505 行</span></span><br><span class="line"><span class="comment">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">// 这里</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 90</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">   Element root = doc.getDocumentElement();</span><br><span class="line">   <span class="comment">// 从 xml 根节点开始解析文件</span></span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p>
<h5 id="doRegisterBeanDefinitions："><a href="#doRegisterBeanDefinitions：" class="headerlink" title="doRegisterBeanDefinitions："></a>doRegisterBeanDefinitions：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 116</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span></span><br><span class="line">   <span class="comment">// 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span></span><br><span class="line">   <span class="comment">// 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span></span><br><span class="line">   BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">   <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="comment">// 这块说的是根节点 &lt;beans ... profile="dev" /&gt; 中的 profile 是否是当前环境需要的，</span></span><br><span class="line">      <span class="comment">// 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析</span></span><br><span class="line">      <span class="comment">// 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span></span><br><span class="line">      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                     <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   preProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line">   <span class="comment">// 往下看</span></span><br><span class="line">   parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">   postProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p>
<p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p>
<p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="comment">// 其他的属于 custom 的</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">// 解析 default namespace 下面的几个元素</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p>
<p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p>
<blockquote>
<p>这里的四个标签之所以是 <strong>default</strong> 的，是因为它们是处于这个 namespace 下定义的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br></pre></td></tr></table></figure>

<p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 <strong>xmlns</strong> 就是咯。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p>
<p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。</p>
<p>假如读者想分析 <code>&lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt;</code> 的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/mvc   </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">       "</span></span></span><br><span class="line"><span class="tag">      <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>同理，以后你要是碰到 <code>&lt;dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。</p>
</blockquote>
<p>回过神来，看看处理 default 标签的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;import /&gt; 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;alias /&gt; 标签定义</span></span><br><span class="line">      <span class="comment">// &lt;alias name="fromName" alias="toName"/&gt;</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <code>&lt;bean /&gt;</code> 标签出来说。</p>
<h5 id="processBeanDefinition-解析-bean-标签"><a href="#processBeanDefinition-解析-bean-标签" class="headerlink" title="processBeanDefinition 解析 bean 标签"></a>processBeanDefinition 解析 bean 标签</h5><p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p>
<p>// DefaultBeanDefinitionDocumentReader 298</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span></span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p>
<table>
<thead>
<tr>
<th>Property</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>class</td>
<td>类的全限定名</td>
</tr>
<tr>
<td>name</td>
<td>可指定 id、name(用逗号、分号、空格分隔)</td>
</tr>
<tr>
<td>scope</td>
<td>作用域</td>
</tr>
<tr>
<td>constructor arguments</td>
<td>指定构造参数</td>
</tr>
<tr>
<td>properties</td>
<td>设置属性的值</td>
</tr>
<tr>
<td>autowiring mode</td>
<td>no(默认值)、byName、byType、 constructor</td>
</tr>
<tr>
<td>lazy-initialization mode</td>
<td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td>
</tr>
<tr>
<td>initialization method</td>
<td>bean 属性设置完成后，会调用这个方法</td>
</tr>
<tr>
<td>destruction method</td>
<td>bean 销毁后的回调方法</td>
</tr>
</tbody></table>
<p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p>
<p>简单地说就是像下面这样子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">name</span>=<span class="string">"name1, name2, name3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.ExampleBean"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- property 的几种情况 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p>
<p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p>
<p>// BeanDefinitionParserDelegate 428</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">   String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">   <span class="comment">// 当然，如果你不定义 name 属性的话，就是空的了</span></span><br><span class="line">   <span class="comment">// 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String beanName = id;</span><br><span class="line">   <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">               <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">   <span class="comment">// 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span></span><br><span class="line">      <span class="comment">// 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;<span class="comment">// 按照我们的思路，这里 containingBean 是 null 的</span></span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span></span><br><span class="line">               <span class="comment">//   1. beanName 为：com.javadoop.example.MessageServiceImpl#0</span></span><br><span class="line">               <span class="comment">//   2. beanClassName 为：com.javadoop.example.MessageServiceImpl</span></span><br><span class="line">              </span><br><span class="line">               beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">               </span><br><span class="line">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                     <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">   String className = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      String parent = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span></span><br><span class="line">      AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p>
<p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span></span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span></span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p>
<p>下面，我们开始说说注册 Bean 吧。</p>
<h5 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h5><p>// BeanDefinitionReaderUtils 143</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 注册这个 Bean</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">         <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p>
<p>// DefaultListableBeanFactory 793</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span></span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">   oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         <span class="comment">// 如果不允许覆盖的话，抛异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         <span class="comment">// log...用框架定义的 Bean 覆盖用户自定义的 Bean </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         <span class="comment">// log...用新的 Bean 覆盖旧的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">      <span class="comment">// 注意，"注册Bean" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">      <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">         <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">            updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">         <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">         <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">         <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">         <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">         <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">         <span class="comment">//     registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">         <span class="comment">// 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面"手动"注册一些 Bean，</span></span><br><span class="line">         <span class="comment">// 如 "environment"、"systemProperties" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">         <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个不重要，在预初始化的时候会用到，不必管它。</span></span><br><span class="line">      <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p>
<p>——— 分割线 ———</p>
<p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p>
<h3 id="Bean-容器实例化完成后"><a href="#Bean-容器实例化完成后" class="headerlink" title="Bean 容器实例化完成后"></a>Bean 容器实例化完成后</h3><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p>
<p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);          </span><br><span class="line">         </span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h3><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p>
<p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span></span><br><span class="line">   <span class="comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 设置 BeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span></span><br><span class="line">   <span class="comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span></span><br><span class="line">   <span class="comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span></span><br><span class="line">   <span class="comment">// 注意：它不仅仅回调 ApplicationContextAware，</span></span><br><span class="line">   <span class="comment">//   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span></span><br><span class="line">   <span class="comment">// Spring 会通过其他方式来处理这些依赖。</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span></span><br><span class="line"><span class="comment">    * 之前我们说过，"当前 ApplicationContext 持有一个 BeanFactory"，这里解释了第一行。</span></span><br><span class="line"><span class="comment">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span></span><br><span class="line"><span class="comment">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span></span><br><span class="line"><span class="comment">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span></span><br><span class="line">   <span class="comment">// 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span></span><br><span class="line">   <span class="comment">// tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span></span><br><span class="line">   <span class="comment">//    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下面几行代码我们可以知道，Spring 往往很 "智能" 就是因为它会帮我们默认注册一些有用的 bean，</span></span><br><span class="line"><span class="comment">    * 我们也可以选择覆盖</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 如果没有定义 "environment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemProperties" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemEnvironment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p>
<h3 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h3><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p>
<p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p>
<p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p>
<p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p>
<p>// AbstractApplicationContext.java 834</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span></span><br><span class="line">   <span class="comment">// 什么，看代码这里没有初始化 Bean 啊！</span></span><br><span class="line">   <span class="comment">// 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">   <span class="comment">// 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">   <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始初始化</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p>
<h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><p>// DefaultListableBeanFactory 728</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// this.beanDefinitionNames 保存了所有的 beanNames</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 合并父 Bean 中的配置，注意 &lt;bean id="" class="" parent="" /&gt; 中的 parent，用的不多吧，</span></span><br><span class="line">      <span class="comment">// 考虑到这可能会影响大家的理解，我在附录中解释了一下 "Bean 继承"，不了解的请到附录中看一下</span></span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         <span class="comment">// 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="comment">// FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span></span><br><span class="line">            <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">// 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span></span><br><span class="line">            <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">               isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">               </span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">   <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p>
<h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p>
<p>// AbstractBeanFactory 196</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span></span><br><span class="line"><span class="comment">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span></span><br><span class="line">   <span class="comment">// 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span></span><br><span class="line">   <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 注意跟着这个，这个是返回值</span></span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查下是不是已经创建过了</span></span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span></span><br><span class="line">   <span class="comment">// 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">"..."</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span></span><br><span class="line">      <span class="comment">// 如果是 FactoryBean 的话，返回它创建的那个实例对象</span></span><br><span class="line">      <span class="comment">// (FactoryBean 知识，读者若不清楚请移步附录)</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span></span><br><span class="line">         <span class="comment">// 往往是因为陷入了循环引用</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查一下这个 BeanDefinition 在容器中是否存在</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span></span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回父容器的查询结果</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         <span class="comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">         <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="comment">// 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span></span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 注册一下依赖关系</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">// 先初始化被依赖项</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// 执行创建 Bean，详情后面再说</span></span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     <span class="keyword">throw</span> ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">            Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">// 执行创建 Bean</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行创建 Bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                     <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                     <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException</span>;</span><br></pre></td></tr></table></figure>

<p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p>
<p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p>
<p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p>
<p>好了，读者要知道这么回事就可以了，继续向前。</p>
<p>// AbstractAutowireCapableBeanFactory 447</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保 BeanDefinition 中的 Class 被加载</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span></span><br><span class="line">   <span class="comment">// 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span></span><br><span class="line">   <span class="comment">// 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">      <span class="comment">// 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span></span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 重头戏，创建 bean</span></span><br><span class="line">   Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建-Bean"><a href="#创建-Bean" class="headerlink" title="创建 Bean"></a>创建 Bean</h4><p>我们继续往里看 doCreateBean 这个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 "bean 实例"</span></span><br><span class="line">   <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// 类型</span></span><br><span class="line">   Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">   mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">   <span class="comment">// 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span></span><br><span class="line">   <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">               <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span></span><br><span class="line">         <span class="comment">// 这里就是处理 bean 初始化完成后的各种回调</span></span><br><span class="line">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                     <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                     <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                     <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                     <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p>
<p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p>
<p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p>
<h5 id="创建-Bean-实例"><a href="#创建-Bean-实例" class="headerlink" title="创建 Bean 实例"></a>创建 Bean 实例</h5><p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 确保已经加载了此 class</span></span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验一下这个类的访问权限</span></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">      <span class="comment">// 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span></span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span></span><br><span class="line">   <span class="comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span></span><br><span class="line">   <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resolved = <span class="keyword">true</span>;</span><br><span class="line">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">         <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">         <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 无参构造函数</span></span><br><span class="line">         <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断是否采用有参构造函数</span></span><br><span class="line">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">      <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用无参构造函数</span></span><br><span class="line">   <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 实例化</span></span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包装一下，返回</span></span><br><span class="line">      BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      <span class="keyword">return</span> bw;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，关键的地方在于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure>

<p>这里会进行实际的实例化过程，我们进去看看:</p>
<p>// SimpleInstantiationStrategy 59</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span></span><br><span class="line">   <span class="comment">// 方法覆写 请参见附录"方法注入"中对 lookup-method 和 replaced-method 的介绍</span></span><br><span class="line">   <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">      <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">         <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  constructorToUse = clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 利用构造方法进行实例化</span></span><br><span class="line">      <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span></span><br><span class="line">      <span class="comment">// tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span></span><br><span class="line">      <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p>
<h5 id="bean-属性注入"><a href="#bean-属性注入" class="headerlink" title="bean 属性注入"></a>bean 属性注入</h5><p>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p>
<p>// AbstractAutowireCapableBeanFactory 1203</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// bean 实例的所有属性都在这里了</span></span><br><span class="line">   PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span></span><br><span class="line">   <span class="comment">// InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span></span><br><span class="line">   <span class="comment">// 我也没找到有实际的使用，所以我们暂且忽略这块吧</span></span><br><span class="line">   <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span></span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过类型装配。复杂一些</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">         <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">               <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span></span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h5><p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Object wrappedBean = bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">      <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="id-和-name"><a href="#id-和-name" class="headerlink" title="id 和 name"></a>id 和 name</h3><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p>
<p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beanFactory.getBean(<span class="string">"beanName or alias"</span>);</span><br></pre></td></tr></table></figure>

<p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">name</span>=<span class="string">"m1, m2, m3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"m1, m2, m3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p>
<p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 messageService，没有别名。</p>
<h3 id="配置是否允许-Bean-覆盖、是否允许循环依赖"><a href="#配置是否允许-Bean-覆盖、是否允许循环依赖" class="headerlink" title="配置是否允许 Bean 覆盖、是否允许循环依赖"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h3><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p>
<p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p>
<p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p>
<p>添加这两个属性的作者 Juergen Hoeller 在这个 <a href="https://jira.spring.io/browse/SPR-4374" target="_blank" rel="noopener">jira</a> 的讨论中说明了怎么配置这两个属性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoBeanOverridingContextLoader</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeContext</span><span class="params">(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.customizeContext(servletContext, applicationContext);</span><br><span class="line">    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class="line">    arac.setAllowBeanDefinitionOverriding(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ContextLoader <span class="title">createContextLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NoBeanOverridingContextLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.javadoop.MyContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果以上方式不能满足你的需求，请参考这个链接：<a href="http://blog.csdn.net/zgmzyr/article/details/39380477" target="_blank" rel="noopener">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p>
<h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>应该不必做过多解释了吧，看每个文件第一行的 profile=””。</p>
<p>当然，我们也可以在一个配置文件中使用：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>理解起来也很简单吧。</p>
<p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p>
<p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p>
<p>最简单的方式莫过于在程序启动的时候指定：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dspring.profiles.active="profile1,profile2"</span><br></pre></td></tr></table></figure>

<blockquote>
<p>profile 可以激活多个</p>
</blockquote>
<p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"development"</span>);</span><br><span class="line">ctx.register(SomeConfig<span class="class">.<span class="keyword">class</span>, <span class="title">StandaloneDataConfig</span>.<span class="title">class</span>, <span class="title">JndiDataConfig</span>.<span class="title">class</span>)</span>;</span><br><span class="line">ctx.refresh(); <span class="comment">// 重启</span></span><br></pre></td></tr></table></figure>

<p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Dspring.profiles.active=prod -jar JavaDoop.jar</span><br></pre></td></tr></table></figure>

<p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。</p>
<h3 id="工厂模式生成-Bean"><a href="#工厂模式生成-Bean" class="headerlink" title="工厂模式生成 Bean"></a>工厂模式生成 Bean</h3><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p>
<p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p>
<p>静态工厂：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"examples.ClientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例工厂：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createAccountServiceInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getObjectType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Car car ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123; <span class="keyword">this</span>.car = car;  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String make; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMake</span><span class="params">(String m)</span></span>&#123; <span class="keyword">this</span>.make =m ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">this</span>.year = y; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span></span>&#123; </span><br><span class="line">      <span class="comment">// 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span></span><br><span class="line">      CarBuilder cb = CarBuilder.car();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(year!=<span class="number">0</span>) cb.setYear(<span class="keyword">this</span>.year);</span><br><span class="line">      <span class="keyword">if</span>(StringUtils.hasText(<span class="keyword">this</span>.make)) cb.setMake( <span class="keyword">this</span>.make ); </span><br><span class="line">      <span class="keyword">return</span> cb.factory(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;Car&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Car<span class="class">.<span class="keyword">class</span> </span>; &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看看装配的时候是怎么配置的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"com.javadoop.MyCarFactoryBean"</span> <span class="attr">id</span> = <span class="string">"car"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"make"</span> <span class="attr">value</span> =<span class="string">"Honda"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"year"</span> <span class="attr">value</span> =<span class="string">"1984"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"com.javadoop.Person"</span> <span class="attr">id</span> = <span class="string">"josh"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"car"</span> <span class="attr">ref</span> = <span class="string">"car"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p>
<p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarConfiguration</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyCarFactoryBean <span class="title">carFactoryBean</span><span class="params">()</span></span>&#123; </span><br><span class="line">      MyCarFactoryBean cfb = <span class="keyword">new</span> MyCarFactoryBean();</span><br><span class="line">      cfb.setMake(<span class="string">"Honda"</span>);</span><br><span class="line">      cfb.setYear(<span class="number">1984</span>);</span><br><span class="line">      <span class="keyword">return</span> cfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">aPerson</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      <span class="comment">// 注意这里的不同</span></span><br><span class="line">    person.setCar(carFactoryBean().getObject());</span><br><span class="line">    <span class="keyword">return</span> person; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p>
<h3 id="初始化-Bean-的回调"><a href="#初始化-Bean-的回调" class="headerlink" title="初始化 Bean 的回调"></a>初始化 Bean 的回调</h3><p>有以下四种方案：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="销毁-Bean-的回调"><a href="#销毁-Bean-的回调" class="headerlink" title="销毁 Bean 的回调"></a>销毁 Bean 的回调</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(destroyMethod = <span class="string">"cleanup"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>既然文中说到了这个，顺便提一下好了。</p>
<p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p>
<p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.javadoop.learning.utils.StringToEnumConverterFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p>
<p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p>
<p>来看一个很简单的例子，这样比什么都管用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DateUtils.parseDate(source, <span class="string">"yyyy-MM-dd"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, <span class="string">"yyyy-MM-dd HH:mm"</span>, <span class="string">"HH:mm:ss"</span>, <span class="string">"HH:mm"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p>
<h3 id="Bean-继承"><a href="#Bean-继承" class="headerlink" title="Bean 继承"></a>Bean 继承</h3><p>在初始化 Bean 的地方，我们说过了这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure>

<p>这里涉及到的就是 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p>
<p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p>
<p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p>
<p>看如下一个例子:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"inheritedTestBean"</span> <span class="keyword">abstract</span>=<span class="string">"true"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"parent"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"inheritsWithDifferentClass"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span><br><span class="line">        parent=<span class="string">"inheritedTestBean"</span> init-method=<span class="string">"initialize"</span>&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"override"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p>
<p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p>
<p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p>
<p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="keyword">abstract</span>=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"parent"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p>
<p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p>
<p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p>
<p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p>
<h4 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h4><p>我们来看一下 Spring Reference 中提供的一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no more Spring imports!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCommand"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"myCommand"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p>
<p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span>(<span class="string">"myCommand"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt;</code></p>
</blockquote>
<p>甚至，我们可以像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p>
</blockquote>
<h4 id="replaced-method"><a href="#replaced-method" class="headerlink" title="replaced-method"></a>replaced-method</h4><p>记住它的功能，就是替换掉 bean 中的一些方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some real code...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法覆写，注意要实现 MethodReplacer 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">beans</span>.<span class="title">factory</span>.<span class="title">support</span>.<span class="title">MethodReplacer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></span><br><span class="line">        String input = (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置也很简单：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p>
</blockquote>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p>
<p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p>
<p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p>
<p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p>
<p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p>
<p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p>
<p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p>
<hr>
<p>本文摘自以下链接:</p>
<pre><code>https://javadoop.com/post/spring-ioc</code></pre>]]></content>
      <categories>
        <category>open-source</category>
      </categories>
  </entry>
</search>
